# Turing - Random NFT

## What is Turing?
Turing is a system for interacting with the outside world from within solidity smart contracts. All data returned from external APIs, such as social networking or weather data are deposited into a public data-storage contract on Ethereum Mainnet. This extra data allows replicas, verifiers, and fraud-detectors to reproduce and validate the Boba L2 blockchain, block by block.

Using Turing is as easy as calling specific functions from inside your smart contract. For example, to obtain a random number for minting NFTs, call:

```javascript

  // ERC721.sol
  random_number = turing.getRandom()

  // Test/Debug Response
  Turing NFT Random 256
    256 bit random number as a BigInt = 61245594159531997717158776666900035572992757857563713350570408643552830626492n
    Minted an NFT with Attribute A = 135 and Attribute B = 103
    Minted a pirate with a green hat
    ✓ should mint an NFT with random attributes (65ms)

```

## What is this example about?
This example shows how to use `turingHelper.turingRandom()` to receive a very strong pseudo-random number from directly from Geth.

Since the Random number is generated by Geth itself, you don't need to deploy an AWS lambda or other backend for this.

## How does it work?
Using Turing to mint an NFT with 256 random attributes in a single transaction

With Turing, your ERC721 contract can generate a cryptographically strong 256 bit random number immediately prior to the execution flow moving to the `mint` function. This is an _atomic_ transaction - everything takes places within one transaction:

```javascript

  // modified mint function in a standard ERC721.sol
  function mint(address to, uint256 tokenId) public {
    uint256 result = myHelper.TuringRandom();
    bytes memory i_bytes = abi.encodePacked(result);
    uint8 attribute_1  = uint8(i_bytes[ 0]);
    uint8 attribute_2  = uint8(i_bytes[ 1]);
    ...
    uint8 attribute_32 = uint8(i_bytes[31]);
    // use the attributes here to e.g. set URI/Attributes etc
    _mint(to, tokenId);
    emit MintedRandom(result, attribute_1, attribute_2, ...);
  }

  // pseudocode transaction response from test system (see boba/turing/test/NFT_random.ts)
  256 bit random number as a BigInt = 61245594159531997717158776666900035572992757857563713350570408643552830626492n
  Minted an NFT with Attribute A = 135 and Attribute B = 103
  Minted a pirate with a green hat
  ✓ should mint an NFT with random attributes (65ms)

```

To use this functionality, deploy your `TuringHelper` contract, provide its address to your ERC721 contract, and make the `TuringHelper` aware of the new caller:

```javascript

  // deploy your Turing helper
  myTuringHelper = await Factory__Helper.deploy()

  // deploy your ERC721 contract with the
  erc721 = await Factory__ERC721.deploy("RandomERC721", "RER", myTuringHelper.address)

  // restrict your myHelper to accept only requests from your ERC721
  await myTuringHelper.addPermittedCaller(erc721.address)

```

Then, register and fund your Turing Credit account:

```javascript

  const ONE_BOBA = utils.parseEther('1')
  await turingCredit.addBalanceTo(ONE_BOBA, myTuringHelper.address)

```

**All done**! Each Turing request costs 0.01 BOBA, so 1 BOBA is enough for 100 Turing requests. Have fun. You can find [example code and an ERC721 that uses Turing here](./test/006_NFT_random.ts) and a [fully-featured Turing-ready NFT system here](../../boba_community/turing-monsters/README.md).
