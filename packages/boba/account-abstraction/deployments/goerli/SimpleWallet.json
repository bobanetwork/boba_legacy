{
  "address": "0x1039fFeFC623aA8C5566F1290e1a05ec162a4089",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract EntryPoint",
          "name": "anEntryPoint",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "anOwner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldEntryPoint",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newEntryPoint",
          "type": "address"
        }
      ],
      "name": "EntryPointChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "addDeposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "entryPoint",
      "outputs": [
        {
          "internalType": "contract EntryPoint",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dest",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "func",
          "type": "bytes"
        }
      ],
      "name": "exec",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "dest",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "func",
          "type": "bytes[]"
        }
      ],
      "name": "execBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dest",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "func",
          "type": "bytes"
        }
      ],
      "name": "execFromEntryPoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "dest",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newEntryPoint",
          "type": "address"
        }
      ],
      "name": "updateEntryPoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "callGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "paymaster",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "paymasterData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct UserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "requestId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "missingWalletFunds",
          "type": "uint256"
        }
      ],
      "name": "validateUserOp",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "withdrawAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawDepositTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "args": [
    "0x602aB3881Ff3Fa8dA60a8F44Cf633e91bA1FdB69",
    "0xd21934eD8eAf27a67f0A70042Af50A1D6d195E81"
  ],
  "solcInputHash": "e483154fa64ffd3f4176544534164472",
  "metadata": "{\"compiler\":{\"version\":\"0.8.12+commit.f00d7308\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract EntryPoint\",\"name\":\"anEntryPoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"anOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldEntryPoint\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newEntryPoint\",\"type\":\"address\"}],\"name\":\"EntryPointChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"contract EntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"func\",\"type\":\"bytes\"}],\"name\":\"exec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"dest\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"func\",\"type\":\"bytes[]\"}],\"name\":\"execBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"func\",\"type\":\"bytes\"}],\"name\":\"execFromEntryPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newEntryPoint\",\"type\":\"address\"}],\"name\":\"updateEntryPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"paymasterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"missingWalletFunds\",\"type\":\"uint256\"}],\"name\":\"validateUserOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDepositTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"updateEntryPoint(address)\":{\"params\":{\"newEntryPoint\":\"the new entrypoint to trust.\"}},\"withdrawDepositTo(address,uint256)\":{\"params\":{\"amount\":\"to withdraw\",\"withdrawAddress\":\"target to send to\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addDeposit()\":{\"notice\":\"deposit more funds for this wallet in the entryPoint\"},\"entryPoint()\":{\"notice\":\"return the entryPoint used by this wallet. subclass should return the current entryPoint used by this wallet.\"},\"exec(address,uint256,bytes)\":{\"notice\":\"execute a transaction (called directly from owner, not by entryPoint)\"},\"execBatch(address[],bytes[])\":{\"notice\":\"execute a sequence of transaction\"},\"getDeposit()\":{\"notice\":\"check current wallet deposit in the entryPoint\"},\"nonce()\":{\"notice\":\"return the wallet nonce. subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\"},\"transfer(address,uint256)\":{\"notice\":\"transfer eth value to a destination address\"},\"updateEntryPoint(address)\":{\"notice\":\"expose an api to modify the entryPoint. must be called by current \\\"admin\\\" of the wallet.\"},\"validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,address,bytes,bytes),bytes32,uint256)\":{\"notice\":\"Validate user's signature and nonce. subclass doesn't override this method. instead, it should override the specific internal validation methods.\"},\"withdrawDepositTo(address,uint256)\":{\"notice\":\"withdraw value from the wallet's deposit\"}},\"notice\":\"minimal wallet.  this is sample minimal wallet.  has execute, eth handling methods  has a single signer that can send requests through the entryPoint.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/samples/SimpleWallet.sol\":\"SimpleWallet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xbc991a1cf357ce19480831a40792c814238a3b5458134703682abd8aa39719fb\",\"license\":\"MIT\"},\"contracts/BaseWallet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./IWallet.sol\\\";\\nimport \\\"./EntryPoint.sol\\\";\\n\\n/**\\n * Basic wallet implementation.\\n * this contract provides the basic logic for implementing the IWallet interface  - validateUserOp\\n * specific wallet implementation should inherit it and provide the wallet-specific logic\\n */\\nabstract contract BaseWallet is IWallet {\\n    using UserOperationLib for UserOperation;\\n\\n    /**\\n     * return the wallet nonce.\\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\\n     */\\n    function nonce() public view virtual returns (uint256);\\n\\n    /**\\n     * return the entryPoint used by this wallet.\\n     * subclass should return the current entryPoint used by this wallet.\\n     */\\n    function entryPoint() public view virtual returns (EntryPoint);\\n\\n    /**\\n     * Validate user's signature and nonce.\\n     * subclass doesn't override this method. instead, it should override the specific internal validation methods.\\n     */\\n    function validateUserOp(UserOperation calldata userOp, bytes32 requestId, uint256 missingWalletFunds) external override {\\n        _requireFromEntryPoint();\\n        _validateSignature(userOp, requestId);\\n        //during construction, the \\\"nonce\\\" field hold the salt.\\n        // if we assert it is zero, then we allow only a single wallet per owner.\\n        if (userOp.initCode.length == 0) {\\n            _validateAndUpdateNonce(userOp);\\n        }\\n        _payPrefund(missingWalletFunds);\\n    }\\n\\n    /**\\n     * ensure the request comes from the known entrypoint.\\n     */\\n    function _requireFromEntryPoint() internal virtual view {\\n        require(msg.sender == address(entryPoint()), \\\"wallet: not from EntryPoint\\\");\\n    }\\n\\n    /**\\n     * validate the signature is valid for this message.\\n     * @param userOp validate the userOp.signature field\\n     * @param requestId convenient field: the hash of the request, to check the signature against\\n     *          (also hashes the entrypoint and chain-id)\\n     */\\n    function _validateSignature(UserOperation calldata userOp, bytes32 requestId) internal virtual view;\\n\\n    /**\\n     * validate the current nonce matches the UserOperation nonce.\\n     * then it should update the wallet's state to prevent replay of this UserOperation.\\n     * called only if initCode is empty (since \\\"nonce\\\" field is used as \\\"salt\\\" on wallet creation)\\n     * @param userOp the op to validate.\\n     */\\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal virtual;\\n\\n    /**\\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\\n     * subclass MAY override this method for better funds management\\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\\n     * it will not be required to send again)\\n     * @param missingWalletFunds the minimum value this method should send the entrypoint.\\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n     */\\n    function _payPrefund(uint256 missingWalletFunds) internal virtual {\\n        if (missingWalletFunds != 0) {\\n            //pay required prefund. make sure NOT to use the \\\"gas\\\" opcode, which is banned during validateUserOp\\n            // (and used by default by the \\\"call\\\")\\n            (bool success,) = payable(msg.sender).call{value : missingWalletFunds, gas : type(uint256).max}(\\\"\\\");\\n            (success);\\n            //ignore failure (its EntryPoint's job to verify, not wallet.)\\n        }\\n    }\\n\\n    /**\\n     * expose an api to modify the entryPoint.\\n     * must be called by current \\\"admin\\\" of the wallet.\\n     * @param newEntryPoint the new entrypoint to trust.\\n     */\\n    function updateEntryPoint(address newEntryPoint) external {\\n        _requireFromAdmin();\\n        _updateEntryPoint(newEntryPoint);\\n    }\\n\\n    /**\\n     * ensure the caller is allowed \\\"admin\\\" operations (such as changing the entryPoint)\\n     * default implementation trust the wallet itself (or any signer that passes \\\"validateUserOp\\\")\\n     * to be the \\\"admin\\\"\\n     */\\n    function _requireFromAdmin() internal view virtual {\\n        require(msg.sender == address(this) || msg.sender == address(entryPoint()), \\\"not admin\\\");\\n    }\\n\\n    /**\\n     * update the current entrypoint.\\n     * subclass should override and update current entrypoint\\n     */\\n    function _updateEntryPoint(address) internal virtual;\\n}\\n\",\"keccak256\":\"0x27cd992195d685d2fde27151b360c5b0de139481b6555b11685b9b38d6885ff1\",\"license\":\"GPL-3.0\"},\"contracts/EntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./StakeManager.sol\\\";\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IWallet.sol\\\";\\nimport \\\"./IPaymaster.sol\\\";\\n\\nimport \\\"./ICreate2Deployer.sol\\\";\\n\\ncontract EntryPoint is StakeManager {\\n\\n    using UserOperationLib for UserOperation;\\n\\n    enum PaymentMode {\\n        paymasterDeposit, // if paymaster is set, use paymaster's deposit to pay.\\n        walletDeposit // pay with wallet deposit.\\n    }\\n\\n    address public immutable create2factory;\\n\\n    /***\\n     * An event emitted after each successful request\\n     * @param requestId - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request\\n     * @param actualGasCost - the total cost (in gas) of this request.\\n     * @param actualGasPrice - the actual gas price the sender agreed to pay.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     */\\n    event UserOperationEvent(bytes32 indexed requestId, address indexed sender, address indexed paymaster, uint256 nonce, uint256 actualGasCost, uint256 actualGasPrice, bool success);\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param requestId the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(bytes32 indexed requestId, address indexed sender, uint256 nonce, bytes revertReason);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param paymaster - if paymaster.validatePaymasterUserOp fails, this will be the paymaster's address. if validateUserOp failed,\\n     *       this value will be zero (since it failed before accessing the paymaster)\\n     *  @param reason - revert reason\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of wallet/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, address paymaster, string reason);\\n\\n    /**\\n     * @param _create2factory - contract to \\\"create2\\\" wallets (not the EntryPoint itself, so that the EntryPoint can be upgraded)\\n     * @param _paymasterStake - minimum required locked stake for a paymaster\\n     * @param _unstakeDelaySec - minimum time (in seconds) a paymaster stake must be locked\\n     */\\n    constructor(address _create2factory, uint256 _paymasterStake, uint32 _unstakeDelaySec) StakeManager(_paymasterStake, _unstakeDelaySec) {\\n        require(_create2factory != address(0), \\\"invalid create2factory\\\");\\n        require(_unstakeDelaySec > 0, \\\"invalid unstakeDelay\\\");\\n        require(_paymasterStake > 0, \\\"invalid paymasterStake\\\");\\n        create2factory = _create2factory;\\n    }\\n\\n    /**\\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\\n     * @param beneficiary the address to receive the fees\\n     * @param amount amount to transfer.\\n     */\\n    function _compensate(address payable beneficiary, uint256 amount) internal {\\n        require(beneficiary != address(0), \\\"invalid beneficiary\\\");\\n        (bool success,) = beneficiary.call{value : amount}(\\\"\\\");\\n        require(success);\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\\n\\n        uint256 opslen = ops.length;\\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\\n\\n    unchecked {\\n        for (uint256 i = 0; i < opslen; i++) {\\n            uint256 preGas = gasleft();\\n            UserOperation calldata op = ops[i];\\n\\n            bytes memory context;\\n            uint256 contextOffset;\\n            bytes32 requestId = getRequestId(op);\\n            uint256 prefund;\\n            PaymentMode paymentMode;\\n            (prefund, paymentMode, context) = _validatePrepayment(i, op, requestId);\\n            assembly {contextOffset := context}\\n            opInfos[i] = UserOpInfo(\\n                requestId,\\n                prefund,\\n                paymentMode,\\n                contextOffset,\\n                preGas - gasleft() + op.preVerificationGas\\n            );\\n        }\\n\\n        uint256 collected = 0;\\n\\n        for (uint256 i = 0; i < ops.length; i++) {\\n            uint256 preGas = gasleft();\\n            UserOperation calldata op = ops[i];\\n            UserOpInfo memory opInfo = opInfos[i];\\n            uint256 contextOffset = opInfo.contextOffset;\\n            bytes memory context;\\n            assembly {context := contextOffset}\\n\\n            try this.innerHandleOp(op, opInfo, context) returns (uint256 _actualGasCost) {\\n                collected += _actualGasCost;\\n            } catch {\\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n                collected += _handlePostOp(i, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\\n            }\\n        }\\n\\n        _compensate(beneficiary, collected);\\n    } //unchecked\\n    }\\n\\n    struct UserOpInfo {\\n        bytes32 requestId;\\n        uint256 prefund;\\n        PaymentMode paymentMode;\\n        uint256 contextOffset;\\n        uint256 preOpGas;\\n    }\\n\\n    /**\\n     * inner function to handle a UserOperation.\\n     * Must be declared \\\"external\\\" to open a call context, but it can only be called by handleOps.\\n     */\\n    function innerHandleOp(UserOperation calldata op, UserOpInfo calldata opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n        require(msg.sender == address(this));\\n\\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\\n        if (op.callData.length > 0) {\\n\\n            (bool success,bytes memory result) = address(op.getSender()).call{gas : op.callGas}(op.callData);\\n            if (!success) {\\n                if (result.length > 0) {\\n                    emit UserOperationRevertReason(opInfo.requestId, op.getSender(), op.nonce, result);\\n                }\\n                mode = IPaymaster.PostOpMode.opReverted;\\n            }\\n        }\\n\\n    unchecked {\\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\\n        return _handlePostOp(0, mode, op, opInfo, context, actualGas);\\n    }\\n    }\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getRequestId(UserOperation calldata userOp) public view returns (bytes32) {\\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\\n    }\\n\\n    /**\\n    * Simulate a call to wallet.validateUserOp and paymaster.validatePaymasterUserOp.\\n    * Validation succeeds if the call doesn't revert.\\n    * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the wallet's data.\\n     *      In order to split the running opcodes of the wallet (validateUserOp) from the paymaster's validatePaymasterUserOp,\\n     *      it should look for the NUMBER opcode at depth=1 (which itself is a banned opcode)\\n     * @return preOpGas total gas used by validation (including contract creation)\\n     * @return prefund the amount the wallet had to prefund (zero in case a paymaster pays)\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external returns (uint256 preOpGas, uint256 prefund) {\\n        uint256 preGas = gasleft();\\n\\n        bytes32 requestId = getRequestId(userOp);\\n        (prefund,,) = _validatePrepayment(0, userOp, requestId);\\n        preOpGas = preGas - gasleft() + userOp.preVerificationGas;\\n\\n        require(msg.sender == address(0), \\\"must be called off-chain with from=zero-addr\\\");\\n    }\\n\\n    function _getPaymentInfo(UserOperation calldata userOp) internal view returns (uint256 requiredPrefund, PaymentMode paymentMode) {\\n        requiredPrefund = userOp.requiredPreFund();\\n        if (userOp.hasPaymaster()) {\\n            paymentMode = PaymentMode.paymasterDeposit;\\n        } else {\\n            paymentMode = PaymentMode.walletDeposit;\\n        }\\n    }\\n\\n    // create the sender's contract if needed.\\n    function _createSenderIfNeeded(UserOperation calldata op) internal {\\n        if (op.initCode.length != 0) {\\n            // note that we're still under the gas limit of validate, so probably\\n            // this create2 creates a proxy account.\\n            // @dev initCode must be unique (e.g. contains the signer address), to make sure\\n            //   it can only be executed from the entryPoint, and called with its initialization code (callData)\\n            address sender1 = ICreate2Deployer(create2factory).deploy(op.initCode, bytes32(op.nonce));\\n            require(sender1 != address(0), \\\"create2 failed\\\");\\n            require(sender1 == op.getSender(), \\\"sender doesn't match create2 address\\\");\\n        }\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     * @param salt the salt parameter, to be passed as \\\"nonce\\\" in the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode, uint256 salt) public view returns (address) {\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                bytes1(0xff),\\n                address(create2factory),\\n                salt,\\n                keccak256(initCode)\\n            )\\n        );\\n\\n        // NOTE: cast last 20 bytes of hash to address\\n        return address(uint160(uint256(hash)));\\n    }\\n\\n    /**\\n     * call wallet.validateUserOp.\\n     * revert (with FailedOp) in case validateUserOp reverts, or wallet didn't send required prefund.\\n     * decrement wallet's deposit if needed\\n     */\\n    function _validateWalletPrepayment(uint256 opIndex, UserOperation calldata op, bytes32 requestId, uint256 requiredPrefund, PaymentMode paymentMode) internal returns (uint256 gasUsedByValidateWalletPrepayment) {\\n    unchecked {\\n        uint256 preGas = gasleft();\\n        _createSenderIfNeeded(op);\\n        uint256 missingWalletFunds = 0;\\n        address sender = op.getSender();\\n        if (paymentMode != PaymentMode.paymasterDeposit) {\\n            uint256 bal = balanceOf(sender);\\n            missingWalletFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\\n        }\\n        try IWallet(sender).validateUserOp{gas : op.verificationGas}(op, requestId, missingWalletFunds) {\\n        } catch Error(string memory revertReason) {\\n            revert FailedOp(opIndex, address(0), revertReason);\\n        } catch {\\n            revert FailedOp(opIndex, address(0), \\\"\\\");\\n        }\\n        if (paymentMode != PaymentMode.paymasterDeposit) {\\n            DepositInfo storage senderInfo = deposits[sender];\\n            uint deposit = senderInfo.deposit;\\n            if (requiredPrefund > deposit) {\\n                revert FailedOp(opIndex, address(0), \\\"wallet didn't pay prefund\\\");\\n            }\\n            senderInfo.deposit = uint112(deposit - requiredPrefund);\\n        }\\n        gasUsedByValidateWalletPrepayment = preGas - gasleft();\\n    }\\n    }\\n\\n    /**\\n     * in case the request has a paymaster:\\n     * validate paymaster is staked and has enough deposit.\\n     * call paymaster.validatePaymasterUserOp.\\n     * revert with proper FailedOp in case paymaster reverts.\\n     * decrement paymaster's deposit\\n     */\\n    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, bytes32 requestId, uint256 requiredPreFund, uint256 gasUsedByValidateWalletPrepayment) internal returns (bytes memory context) {\\n    unchecked {\\n        address paymaster = op.paymaster;\\n        DepositInfo storage paymasterInfo = deposits[paymaster];\\n        uint deposit = paymasterInfo.deposit;\\n        bool staked = paymasterInfo.staked;\\n        if (!staked) {\\n            revert FailedOp(opIndex, paymaster, \\\"not staked\\\");\\n        }\\n        if (deposit < requiredPreFund) {\\n            revert FailedOp(opIndex, paymaster, \\\"paymaster deposit too low\\\");\\n        }\\n        paymasterInfo.deposit = uint112(deposit - requiredPreFund);\\n        uint256 gas = op.verificationGas - gasUsedByValidateWalletPrepayment;\\n        try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, requestId, requiredPreFund) returns (bytes memory _context){\\n            context = _context;\\n        } catch Error(string memory revertReason) {\\n            revert FailedOp(opIndex, paymaster, revertReason);\\n        } catch {\\n            revert FailedOp(opIndex, paymaster, \\\"\\\");\\n        }\\n    }\\n    }\\n\\n    /**\\n     * validate wallet and paymaster (if defined).\\n     * also make sure total validation doesn't exceed verificationGas\\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\\n     */\\n    function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, bytes32 requestId) private returns (uint256 requiredPreFund, PaymentMode paymentMode, bytes memory context){\\n\\n        uint256 preGas = gasleft();\\n        uint256 maxGasValues = userOp.preVerificationGas | userOp.verificationGas |\\n        userOp.callGas | userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\\n        require(maxGasValues <= type(uint120).max, \\\"gas values overflow\\\");\\n        uint256 gasUsedByValidateWalletPrepayment;\\n        (requiredPreFund, paymentMode) = _getPaymentInfo(userOp);\\n\\n        (gasUsedByValidateWalletPrepayment) = _validateWalletPrepayment(opIndex, userOp, requestId, requiredPreFund, paymentMode);\\n\\n        //a \\\"marker\\\" where wallet opcode validation is done and paymaster opcode validation is about to start\\n        // (used only by off-chain simulateValidation)\\n        uint256 marker = block.number;\\n        (marker);\\n\\n        if (paymentMode == PaymentMode.paymasterDeposit) {\\n            (context) = _validatePaymasterPrepayment(opIndex, userOp, requestId, requiredPreFund, gasUsedByValidateWalletPrepayment);\\n        } else {\\n            context = \\\"\\\";\\n        }\\n    unchecked {\\n        uint256 gasUsed = preGas - gasleft();\\n\\n        if (userOp.verificationGas < gasUsed) {\\n            revert FailedOp(opIndex, userOp.paymaster, \\\"Used more than verificationGas\\\");\\n        }\\n    }\\n    }\\n\\n    /**\\n     * process post-operation.\\n     * called just after the callData is executed.\\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\\n     * the excess amount is refunded to the wallet (or paymaster - if it is was used in the request)\\n     * @param opIndex index in the batch\\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\\n     * @param op the user operation\\n     * @param opInfo info collected during validation\\n     * @param context the context returned in validatePaymasterUserOp\\n     * @param actualGas the gas used so far by this user operation\\n     */\\n    function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOperation calldata op, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n        uint256 gasPrice = UserOperationLib.gasPrice(op);\\n    unchecked {\\n        address refundAddress;\\n\\n        address paymaster = op.paymaster;\\n        if (paymaster == address(0)) {\\n            refundAddress = op.getSender();\\n        } else {\\n            refundAddress = paymaster;\\n            if (context.length > 0) {\\n                actualGasCost = actualGas * gasPrice;\\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\\n                    IPaymaster(paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost);\\n                } else {\\n                    try IPaymaster(paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost) {}\\n                    catch Error(string memory reason) {\\n                        revert FailedOp(opIndex, paymaster, reason);\\n                    }\\n                    catch {\\n                        revert FailedOp(opIndex, paymaster, \\\"postOp revert\\\");\\n                    }\\n                }\\n            }\\n        }\\n        actualGas += preGas - gasleft();\\n        actualGasCost = actualGas * gasPrice;\\n        if (opInfo.prefund < actualGasCost) {\\n            revert FailedOp(opIndex, paymaster, \\\"prefund below actualGasCost\\\");\\n        }\\n        uint refund = opInfo.prefund - actualGasCost;\\n        internalIncrementDeposit(refundAddress, refund);\\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\\n        emit UserOperationEvent(opInfo.requestId, op.getSender(), op.paymaster, op.nonce, actualGasCost, gasPrice, success);\\n    } // unchecked\\n    }\\n\\n    /**\\n     * return the storage cells used internally by the EntryPoint for this sender address.\\n     * During `simulateValidation`, allow these storage cells to be accessed\\n     *  (that is, a wallet/paymaster are allowed to access their own deposit balance on the\\n     *  EntryPoint's storage, but no other account)\\n     */\\n    function getSenderStorage(address sender) external view returns (uint256[] memory senderStorageCells) {\\n        uint256 cell;\\n        DepositInfo storage info = deposits[sender];\\n\\n        assembly {\\n            cell := info.slot\\n        }\\n        senderStorageCells = new uint256[](1);\\n        senderStorageCells[0] = cell;\\n    }\\n}\\n\\n\",\"keccak256\":\"0x02984183ea732a05ba39b30b3b5b489992b2a0c33c2733f18718830ce0a38cf7\",\"license\":\"GPL-3.0\"},\"contracts/ICreate2Deployer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/**\\n * create2-based deployer (eip-2470)\\n */\\ninterface ICreate2Deployer {\\n    function deploy(bytes memory initCode, bytes32 salt) external returns (address);\\n}\\n\\n\",\"keccak256\":\"0xba7f42ff30bf38773251115e580ef245937cdedfc3f2bc21b3acc3610a67527b\",\"license\":\"GPL-3.0\"},\"contracts/IPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\\n */\\ninterface IPaymaster {\\n\\n    /**\\n     * payment validation: check if paymaster agree to pay (using its stake)\\n     * revert to reject this request.\\n     * actual payment is done after postOp is called, by deducting actual call cost form the paymaster's stake.\\n     * @param userOp the user operation\\n     * @param requestId hash of the user's request data.\\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n     * @return context value to send to a postOp\\n     *  zero length to signify postOp is not required.\\n     */\\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 requestId, uint256 maxCost) external view returns (bytes memory context);\\n\\n    /**\\n     * post-operation handler.\\n     * Must verify sender is the entryPoint\\n     * @param mode enum with the following options:\\n     *      opSucceeded - user operation succeeded.\\n     *      opReverted  - user op reverted. still has to pay for gas.\\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n     * @param context - the context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - actual gas used so far (without this postOp call).\\n     */\\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\\n\\n    enum PostOpMode {\\n        opSucceeded, // user op succeeded\\n        opReverted, // user op reverted. still has to pay for gas.\\n        postOpReverted //user op succeeded, but caused postOp to revert. Now its a 2nd call, after user's op was deliberately reverted.\\n    }\\n}\\n\",\"keccak256\":\"0x6b26c3accee30544f5c8beeebf492d2a77ef19363b5feefc4bee3fc44c08ad5e\",\"license\":\"GPL-3.0\"},\"contracts/IWallet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\ninterface IWallet {\\n\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param requestId hash of the user's request data. can be used as the basis for signature.\\n     * @param missingWalletFunds missing funds on the wallet's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     */\\n    function validateUserOp(UserOperation calldata userOp, bytes32 requestId, uint256 missingWalletFunds) external;\\n}\\n\",\"keccak256\":\"0x0208088e484bbd582818bd27165cf5b1c132d6b50974b29efe3f8afe1514e35e\",\"license\":\"GPL-3.0\"},\"contracts/StakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or a wallet)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by a paymaster.\\n */\\nabstract contract StakeManager {\\n\\n    /**\\n     * minimum time (in seconds) required to lock a paymaster stake before it can be withdraw.\\n     */\\n    uint32 immutable public unstakeDelaySec;\\n\\n    /**\\n     * minimum value required to stake for a paymaster\\n     */\\n    uint256 immutable public paymasterStake;\\n\\n    constructor(uint256 _paymasterStake, uint32 _unstakeDelaySec) {\\n        unstakeDelaySec = _unstakeDelaySec;\\n        paymasterStake = _paymasterStake;\\n    }\\n\\n    event Deposited(\\n        address indexed account,\\n        uint256 totalDeposit\\n    );\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 withdrawTime\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(\\n        address indexed account,\\n        uint256 withdrawTime\\n    );\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the account's deposit\\n     * @param staked true if this account is staked as a paymaster\\n     * @param stake actual amount of ether staked for this paymaster. must be above paymasterStake\\n     * @param unstakeDelaySec minimum delay to withdraw the stake. must be above the global unstakeDelaySec\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 2^15 eth\\n     *    64 bit for full timestamp\\n     *    32 bit allow 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint64 withdrawTime;\\n    }\\n\\n    /// maps paymaster to their deposits and stakes\\n    mapping(address => DepositInfo) public deposits;\\n\\n    function getDepositInfo(address account) public view returns (DepositInfo memory info) {\\n        return deposits[account];\\n    }\\n\\n    /// return the deposit (for gas payment) of the account\\n    function balanceOf(address account) public view returns (uint256) {\\n        return deposits[account].deposit;\\n    }\\n\\n    receive() external payable {\\n        depositTo(msg.sender);\\n    }\\n\\n    function internalIncrementDeposit(address account, uint256 amount) internal {\\n        DepositInfo storage info = deposits[account];\\n        uint256 newAmount = info.deposit + amount;\\n        require(newAmount <= type(uint112).max, 'deposit overflow');\\n        info.deposit = uint112(newAmount);\\n    }\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) public payable {\\n        internalIncrementDeposit(account, msg.value);\\n        DepositInfo storage info = deposits[account];\\n        emit Deposited(account, info.deposit);\\n    }\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) public payable {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(_unstakeDelaySec >= unstakeDelaySec, \\\"unstake delay too low\\\");\\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \\\"cannot decrease unstake time\\\");\\n        uint256 stake = info.stake + msg.value;\\n        require(stake >= paymasterStake, \\\"stake value too low\\\");\\n        require(stake < type(uint112).max, \\\"stake overflow\\\");\\n        deposits[msg.sender] = DepositInfo(\\n            info.deposit,\\n            true,\\n            uint112(stake),\\n            _unstakeDelaySec,\\n            0\\n        );\\n        emit StakeLocked(msg.sender, stake, _unstakeDelaySec);\\n    }\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(info.unstakeDelaySec != 0, \\\"not staked\\\");\\n        require(info.staked, \\\"already unstaking\\\");\\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\\n        info.withdrawTime = withdrawTime;\\n        info.staked = false;\\n        emit StakeUnlocked(msg.sender, withdrawTime);\\n    }\\n\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        uint256 stake = info.stake;\\n        require(stake > 0, \\\"No stake to withdraw\\\");\\n        require(info.withdrawTime > 0, \\\"must call unlockStake() first\\\");\\n        require(info.withdrawTime <= block.timestamp, \\\"Stake withdrawal is not due\\\");\\n        info.unstakeDelaySec = 0;\\n        info.withdrawTime = 0;\\n        info.stake = 0;\\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\\n        (bool success,) = withdrawAddress.call{value : stake}(\\\"\\\");\\n        require(success, \\\"failed to withdraw stake\\\");\\n    }\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\\n        DepositInfo memory info = deposits[msg.sender];\\n        require(withdrawAmount <= info.deposit, \\\"Withdraw amount too large\\\");\\n        info.deposit = uint112(info.deposit - withdrawAmount);\\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\\n        (bool success,) = withdrawAddress.call{value : withdrawAmount}(\\\"\\\");\\n        require(success, \\\"failed to withdraw\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xde76f2fdf7287b39effddfbfa3b4f1bc0c4976f16980545635cbabef9d681c24\",\"license\":\"GPL-3.0-only\"},\"contracts/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n    /**\\n     * User Operation struct\\n     * @param sender the sender account of this request\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor\\n     * @param callData the method call to execute on this account.\\n     * @param verificationGas gas used for validateUserOp and validatePaymasterUserOp\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter\\n     * @param paymaster if set, the paymaster will pay for the transaction instead of the sender\\n     * @param paymasterData extra data used by the paymaster for validation\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGas;\\n        uint256 verificationGas;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        address paymaster;\\n        bytes paymasterData;\\n        bytes signature;\\n    }\\n\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/miner might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function requiredGas(UserOperation calldata userOp) internal pure returns (uint256) {\\n    unchecked {\\n        //when using a Paymaster, the verificationGas is used also to cover the postOp call.\\n        // our security model might call postOp eventually twice\\n        uint256 mul = hasPaymaster(userOp) ? 3 : 1;\\n        return userOp.callGas + userOp.verificationGas * mul + userOp.preVerificationGas;\\n    }\\n    }\\n\\n    function requiredPreFund(UserOperation calldata userOp) internal view returns (uint256 prefund) {\\n    unchecked {\\n        return requiredGas(userOp) * gasPrice(userOp);\\n    }\\n    }\\n\\n    function hasPaymaster(UserOperation calldata userOp) internal pure returns (bool) {\\n        return userOp.paymaster != address(0);\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        //lighter signature scheme. must match UserOp.ts#packUserOp\\n        bytes calldata sig = userOp.signature;\\n        // copy directly the userOp from calldata up to (but not including) the signature.\\n        // this encoding depends on the ABI encoding of calldata, but is much lighter to copy\\n        // than referencing each field separately.\\n        assembly {\\n            let ofs := userOp\\n            let len := sub(sub(sig.offset, ofs), 32)\\n            ret := mload(0x40)\\n            mstore(0x40, add(ret, add(len, 32)))\\n            mstore(ret, len)\\n            calldatacopy(add(ret, 32), ofs, len)\\n        }\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x95d587a97499a00a24322ad95d360e07bbb8dbf7e80415ec3d792843df8dee0d\",\"license\":\"GPL-3.0\"},\"contracts/samples/SimpleWallet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../BaseWallet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n  * minimal wallet.\\n  *  this is sample minimal wallet.\\n  *  has execute, eth handling methods\\n  *  has a single signer that can send requests through the entryPoint.\\n  */\\ncontract SimpleWallet is BaseWallet {\\n    using ECDSA for bytes32;\\n    using UserOperationLib for UserOperation;\\n\\n    //explicit sizes of nonce, to fit a single storage cell with \\\"owner\\\"\\n    uint96 private _nonce;\\n    address public owner;\\n\\n    function nonce() public view virtual override returns (uint256) {\\n        return _nonce;\\n    }\\n\\n    function entryPoint() public view virtual override returns (EntryPoint) {\\n        return _entryPoint;\\n    }\\n\\n    EntryPoint private _entryPoint;\\n\\n    event EntryPointChanged(address indexed oldEntryPoint, address indexed newEntryPoint);\\n\\n    receive() external payable {}\\n\\n    constructor(EntryPoint anEntryPoint, address anOwner) {\\n        _entryPoint = anEntryPoint;\\n        owner = anOwner;\\n    }\\n\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() internal view {\\n        //directly from EOA owner, or through the entryPoint (which gets redirected through execFromEntryPoint)\\n        require(msg.sender == owner || msg.sender == address(this), \\\"only owner\\\");\\n    }\\n\\n    /**\\n     * transfer eth value to a destination address\\n     */\\n    function transfer(address payable dest, uint256 amount) external onlyOwner {\\n        dest.transfer(amount);\\n    }\\n\\n    /**\\n     * execute a transaction (called directly from owner, not by entryPoint)\\n     */\\n    function exec(address dest, uint256 value, bytes calldata func) external onlyOwner {\\n        _call(dest, value, func);\\n    }\\n\\n    /**\\n     * execute a sequence of transaction\\n     */\\n    function execBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner {\\n        require(dest.length == func.length, \\\"wrong array lengths\\\");\\n        for (uint256 i = 0; i < dest.length; i++) {\\n            _call(dest[i], 0, func[i]);\\n        }\\n    }\\n\\n    /**\\n     * change entry-point:\\n     * a wallet must have a method for replacing the entryPoint, in case the the entryPoint is\\n     * upgraded to a newer version.\\n     */\\n    function _updateEntryPoint(address newEntryPoint) internal override {\\n        emit EntryPointChanged(address(_entryPoint), newEntryPoint);\\n        _entryPoint = EntryPoint(payable(newEntryPoint));\\n    }\\n\\n    function _requireFromAdmin() internal view override {\\n        _onlyOwner();\\n    }\\n\\n    /**\\n     * validate the userOp is correct.\\n     * revert if it doesn't.\\n     * - must only be called from the entryPoint.\\n     * - make sure the signature is of our supported signer.\\n     * - validate current nonce matches request nonce, and increment it.\\n     * - pay prefund, in case current deposit is not enough\\n     */\\n    function _requireFromEntryPoint() internal override view {\\n        require(msg.sender == address(entryPoint()), \\\"wallet: not from EntryPoint\\\");\\n    }\\n\\n    // called by entryPoint, only after validateUserOp succeeded.\\n    function execFromEntryPoint(address dest, uint256 value, bytes calldata func) external {\\n        _requireFromEntryPoint();\\n        _call(dest, value, func);\\n    }\\n\\n    /// implement template method of BaseWallet\\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\\n        require(_nonce++ == userOp.nonce, \\\"wallet: invalid nonce\\\");\\n    }\\n\\n    /// implement template method of BaseWallet\\n    function _validateSignature(UserOperation calldata userOp, bytes32 requestId) internal view override {\\n        bytes32 hash = requestId.toEthSignedMessageHash();\\n        require(owner == hash.recover(userOp.signature), \\\"wallet: wrong signature\\\");\\n    }\\n\\n    function _call(address target, uint256 value, bytes memory data) internal {\\n        (bool success, bytes memory result) = target.call{value : value}(data);\\n        if (!success) {\\n            assembly {\\n                revert(add(result,32), mload(result))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * check current wallet deposit in the entryPoint\\n     */\\n    function getDeposit() public view returns (uint256) {\\n        return entryPoint().balanceOf(address(this));\\n    }\\n\\n    /**\\n     * deposit more funds for this wallet in the entryPoint\\n     */\\n    function addDeposit() public payable {\\n\\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\\\"\\\");\\n        require(req);\\n    }\\n\\n    /**\\n     * withdraw value from the wallet's deposit\\n     * @param withdrawAddress target to send to\\n     * @param amount to withdraw\\n     */\\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner{\\n        entryPoint().withdrawTo(withdrawAddress, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x0efc6f703a27cdf5d44bb340b00e84bfef8f16970b1966086a456642b8627de6\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161109638038061109683398101604081905261002f9161008f565b600180546001600160a01b039384166001600160a01b031990911617905560008054919092166c01000000000000000000000000026001600160601b039091161790556100c9565b6001600160a01b038116811461008c57600080fd5b50565b600080604083850312156100a257600080fd5b82516100ad81610077565b60208401519092506100be81610077565b809150509250929050565b610fbe806100d86000396000f3fe6080604052600436106100ab5760003560e01c8063a9059cbb11610064578063a9059cbb14610185578063affed0e0146101a5578063b0d691fe146101cd578063c399ec88146101eb578063d0cb75fa14610200578063fcbac1f41461022057600080fd5b80630565bb67146100b75780631b71bb6e146100d95780634a58db19146100f95780634d44560d1461010157806380c5c7d0146101215780638da5cb5b1461014157600080fd5b366100b257005b600080fd5b3480156100c357600080fd5b506100d76100d2366004610c8b565b610240565b005b3480156100e557600080fd5b506100d76100f4366004610d14565b61028f565b6100d76102a3565b34801561010d57600080fd5b506100d761011c366004610d38565b610314565b34801561012d57600080fd5b506100d761013c366004610c8b565b610390565b34801561014d57600080fd5b5060005461016890600160601b90046001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561019157600080fd5b506100d76101a0366004610d38565b610398565b3480156101b157600080fd5b506000546001600160601b03165b60405190815260200161017c565b3480156101d957600080fd5b506001546001600160a01b0316610168565b3480156101f757600080fd5b506101bf6103db565b34801561020c57600080fd5b506100d761021b366004610da9565b61045e565b34801561022c57600080fd5b506100d761023b366004610e15565b61055e565b610248610597565b610289848484848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506105f192505050565b50505050565b610297610661565b6102a081610669565b50565b60006102b76001546001600160a01b031690565b6001600160a01b03163460405160006040518083038185875af1925050503d8060008114610301576040519150601f19603f3d011682016040523d82523d6000602084013e610306565b606091505b50509050806102a057600080fd5b61031c610597565b6001546001600160a01b031660405163040b850f60e31b81526001600160a01b03848116600483015260248201849052919091169063205c287890604401600060405180830381600087803b15801561037457600080fd5b505af1158015610388573d6000803e3d6000fd5b505050505050565b6102486106c5565b6103a0610597565b6040516001600160a01b0383169082156108fc029083906000818181858888f193505050501580156103d6573d6000803e3d6000fd5b505050565b60006103ef6001546001600160a01b031690565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa158015610435573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104599190610e69565b905090565b610466610597565b8281146104b05760405162461bcd60e51b815260206004820152601360248201527277726f6e67206172726179206c656e6774687360681b60448201526064015b60405180910390fd5b60005b83811015610557576105458585838181106104d0576104d0610e82565b90506020020160208101906104e59190610d14565b60008585858181106104f9576104f9610e82565b905060200281019061050b9190610e98565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506105f192505050565b8061054f81610ef5565b9150506104b3565b5050505050565b6105666106c5565b610570838361071f565b61057d6040840184610e98565b1515905061058e5761058e8361082c565b6103d6816108be565b600054600160601b90046001600160a01b03163314806105b657503330145b6105ef5760405162461bcd60e51b815260206004820152600a60248201526937b7363c9037bbb732b960b11b60448201526064016104a7565b565b600080846001600160a01b0316848460405161060d9190610f10565b60006040518083038185875af1925050503d806000811461064a576040519150601f19603f3d011682016040523d82523d6000602084013e61064f565b606091505b50915091508161055757805160208201fd5b6105ef610597565b6001546040516001600160a01b038084169216907f450909c1478d09248269d4ad4fa8cba61ca3f50faed58c7aedefa51c7f62b83a90600090a3600180546001600160a01b0319166001600160a01b0392909216919091179055565b6001546001600160a01b031633146105ef5760405162461bcd60e51b815260206004820152601b60248201527f77616c6c65743a206e6f742066726f6d20456e747279506f696e74000000000060448201526064016104a7565b6000610778826040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b90506107c861078b610160850185610e98565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250859392505061090b9050565b600054600160601b90046001600160a01b039081169116146103d65760405162461bcd60e51b815260206004820152601760248201527f77616c6c65743a2077726f6e67207369676e617475726500000000000000000060448201526064016104a7565b600080546020830135916001600160601b03909116908061084c83610f4b565b91906101000a8154816001600160601b0302191690836001600160601b031602179055506001600160601b0316146102a05760405162461bcd60e51b815260206004820152601560248201527477616c6c65743a20696e76616c6964206e6f6e636560581b60448201526064016104a7565b80156102a057604051600090339060001990849084818181858888f193505050503d8060008114610557576040519150601f19603f3d011682016040523d82523d6000602084013e610557565b600080600061091a858561092f565b915091506109278161099f565b509392505050565b6000808251604114156109665760208301516040840151606085015160001a61095a87828585610b5a565b94509450505050610998565b8251604014156109905760208301516040840151610985868383610c47565b935093505050610998565b506000905060025b9250929050565b60008160048111156109b3576109b3610f72565b14156109bc5750565b60018160048111156109d0576109d0610f72565b1415610a1e5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016104a7565b6002816004811115610a3257610a32610f72565b1415610a805760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016104a7565b6003816004811115610a9457610a94610f72565b1415610aed5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016104a7565b6004816004811115610b0157610b01610f72565b14156102a05760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b60648201526084016104a7565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115610b915750600090506003610c3e565b8460ff16601b14158015610ba957508460ff16601c14155b15610bba5750600090506004610c3e565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610c0e573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610c3757600060019250925050610c3e565b9150600090505b94509492505050565b6000806001600160ff1b03831660ff84901c601b01610c6887828885610b5a565b935093505050935093915050565b6001600160a01b03811681146102a057600080fd5b60008060008060608587031215610ca157600080fd5b8435610cac81610c76565b935060208501359250604085013567ffffffffffffffff80821115610cd057600080fd5b818701915087601f830112610ce457600080fd5b813581811115610cf357600080fd5b886020828501011115610d0557600080fd5b95989497505060200194505050565b600060208284031215610d2657600080fd5b8135610d3181610c76565b9392505050565b60008060408385031215610d4b57600080fd5b8235610d5681610c76565b946020939093013593505050565b60008083601f840112610d7657600080fd5b50813567ffffffffffffffff811115610d8e57600080fd5b6020830191508360208260051b850101111561099857600080fd5b60008060008060408587031215610dbf57600080fd5b843567ffffffffffffffff80821115610dd757600080fd5b610de388838901610d64565b90965094506020870135915080821115610dfc57600080fd5b50610e0987828801610d64565b95989497509550505050565b600080600060608486031215610e2a57600080fd5b833567ffffffffffffffff811115610e4157600080fd5b84016101808187031215610e5457600080fd5b95602085013595506040909401359392505050565b600060208284031215610e7b57600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112610eaf57600080fd5b83018035915067ffffffffffffffff821115610eca57600080fd5b60200191503681900382131561099857600080fd5b634e487b7160e01b600052601160045260246000fd5b6000600019821415610f0957610f09610edf565b5060010190565b6000825160005b81811015610f315760208186018101518583015201610f17565b81811115610f40576000828501525b509190910192915050565b60006001600160601b0380831681811415610f6857610f68610edf565b6001019392505050565b634e487b7160e01b600052602160045260246000fdfea264697066735822122032a1247eda0ea1852e82bb4d78ab3401242774a528a931eee4d383a7877398be64736f6c634300080c0033",
  "deployedBytecode": "0x6080604052600436106100ab5760003560e01c8063a9059cbb11610064578063a9059cbb14610185578063affed0e0146101a5578063b0d691fe146101cd578063c399ec88146101eb578063d0cb75fa14610200578063fcbac1f41461022057600080fd5b80630565bb67146100b75780631b71bb6e146100d95780634a58db19146100f95780634d44560d1461010157806380c5c7d0146101215780638da5cb5b1461014157600080fd5b366100b257005b600080fd5b3480156100c357600080fd5b506100d76100d2366004610c8b565b610240565b005b3480156100e557600080fd5b506100d76100f4366004610d14565b61028f565b6100d76102a3565b34801561010d57600080fd5b506100d761011c366004610d38565b610314565b34801561012d57600080fd5b506100d761013c366004610c8b565b610390565b34801561014d57600080fd5b5060005461016890600160601b90046001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561019157600080fd5b506100d76101a0366004610d38565b610398565b3480156101b157600080fd5b506000546001600160601b03165b60405190815260200161017c565b3480156101d957600080fd5b506001546001600160a01b0316610168565b3480156101f757600080fd5b506101bf6103db565b34801561020c57600080fd5b506100d761021b366004610da9565b61045e565b34801561022c57600080fd5b506100d761023b366004610e15565b61055e565b610248610597565b610289848484848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506105f192505050565b50505050565b610297610661565b6102a081610669565b50565b60006102b76001546001600160a01b031690565b6001600160a01b03163460405160006040518083038185875af1925050503d8060008114610301576040519150601f19603f3d011682016040523d82523d6000602084013e610306565b606091505b50509050806102a057600080fd5b61031c610597565b6001546001600160a01b031660405163040b850f60e31b81526001600160a01b03848116600483015260248201849052919091169063205c287890604401600060405180830381600087803b15801561037457600080fd5b505af1158015610388573d6000803e3d6000fd5b505050505050565b6102486106c5565b6103a0610597565b6040516001600160a01b0383169082156108fc029083906000818181858888f193505050501580156103d6573d6000803e3d6000fd5b505050565b60006103ef6001546001600160a01b031690565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa158015610435573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104599190610e69565b905090565b610466610597565b8281146104b05760405162461bcd60e51b815260206004820152601360248201527277726f6e67206172726179206c656e6774687360681b60448201526064015b60405180910390fd5b60005b83811015610557576105458585838181106104d0576104d0610e82565b90506020020160208101906104e59190610d14565b60008585858181106104f9576104f9610e82565b905060200281019061050b9190610e98565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506105f192505050565b8061054f81610ef5565b9150506104b3565b5050505050565b6105666106c5565b610570838361071f565b61057d6040840184610e98565b1515905061058e5761058e8361082c565b6103d6816108be565b600054600160601b90046001600160a01b03163314806105b657503330145b6105ef5760405162461bcd60e51b815260206004820152600a60248201526937b7363c9037bbb732b960b11b60448201526064016104a7565b565b600080846001600160a01b0316848460405161060d9190610f10565b60006040518083038185875af1925050503d806000811461064a576040519150601f19603f3d011682016040523d82523d6000602084013e61064f565b606091505b50915091508161055757805160208201fd5b6105ef610597565b6001546040516001600160a01b038084169216907f450909c1478d09248269d4ad4fa8cba61ca3f50faed58c7aedefa51c7f62b83a90600090a3600180546001600160a01b0319166001600160a01b0392909216919091179055565b6001546001600160a01b031633146105ef5760405162461bcd60e51b815260206004820152601b60248201527f77616c6c65743a206e6f742066726f6d20456e747279506f696e74000000000060448201526064016104a7565b6000610778826040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b90506107c861078b610160850185610e98565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250859392505061090b9050565b600054600160601b90046001600160a01b039081169116146103d65760405162461bcd60e51b815260206004820152601760248201527f77616c6c65743a2077726f6e67207369676e617475726500000000000000000060448201526064016104a7565b600080546020830135916001600160601b03909116908061084c83610f4b565b91906101000a8154816001600160601b0302191690836001600160601b031602179055506001600160601b0316146102a05760405162461bcd60e51b815260206004820152601560248201527477616c6c65743a20696e76616c6964206e6f6e636560581b60448201526064016104a7565b80156102a057604051600090339060001990849084818181858888f193505050503d8060008114610557576040519150601f19603f3d011682016040523d82523d6000602084013e610557565b600080600061091a858561092f565b915091506109278161099f565b509392505050565b6000808251604114156109665760208301516040840151606085015160001a61095a87828585610b5a565b94509450505050610998565b8251604014156109905760208301516040840151610985868383610c47565b935093505050610998565b506000905060025b9250929050565b60008160048111156109b3576109b3610f72565b14156109bc5750565b60018160048111156109d0576109d0610f72565b1415610a1e5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016104a7565b6002816004811115610a3257610a32610f72565b1415610a805760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016104a7565b6003816004811115610a9457610a94610f72565b1415610aed5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016104a7565b6004816004811115610b0157610b01610f72565b14156102a05760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b60648201526084016104a7565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115610b915750600090506003610c3e565b8460ff16601b14158015610ba957508460ff16601c14155b15610bba5750600090506004610c3e565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610c0e573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610c3757600060019250925050610c3e565b9150600090505b94509492505050565b6000806001600160ff1b03831660ff84901c601b01610c6887828885610b5a565b935093505050935093915050565b6001600160a01b03811681146102a057600080fd5b60008060008060608587031215610ca157600080fd5b8435610cac81610c76565b935060208501359250604085013567ffffffffffffffff80821115610cd057600080fd5b818701915087601f830112610ce457600080fd5b813581811115610cf357600080fd5b886020828501011115610d0557600080fd5b95989497505060200194505050565b600060208284031215610d2657600080fd5b8135610d3181610c76565b9392505050565b60008060408385031215610d4b57600080fd5b8235610d5681610c76565b946020939093013593505050565b60008083601f840112610d7657600080fd5b50813567ffffffffffffffff811115610d8e57600080fd5b6020830191508360208260051b850101111561099857600080fd5b60008060008060408587031215610dbf57600080fd5b843567ffffffffffffffff80821115610dd757600080fd5b610de388838901610d64565b90965094506020870135915080821115610dfc57600080fd5b50610e0987828801610d64565b95989497509550505050565b600080600060608486031215610e2a57600080fd5b833567ffffffffffffffff811115610e4157600080fd5b84016101808187031215610e5457600080fd5b95602085013595506040909401359392505050565b600060208284031215610e7b57600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112610eaf57600080fd5b83018035915067ffffffffffffffff821115610eca57600080fd5b60200191503681900382131561099857600080fd5b634e487b7160e01b600052601160045260246000fd5b6000600019821415610f0957610f09610edf565b5060010190565b6000825160005b81811015610f315760208186018101518583015201610f17565b81811115610f40576000828501525b509190910192915050565b60006001600160601b0380831681811415610f6857610f68610edf565b6001019392505050565b634e487b7160e01b600052602160045260246000fdfea264697066735822122032a1247eda0ea1852e82bb4d78ab3401242774a528a931eee4d383a7877398be64736f6c634300080c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "updateEntryPoint(address)": {
        "params": {
          "newEntryPoint": "the new entrypoint to trust."
        }
      },
      "withdrawDepositTo(address,uint256)": {
        "params": {
          "amount": "to withdraw",
          "withdrawAddress": "target to send to"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addDeposit()": {
        "notice": "deposit more funds for this wallet in the entryPoint"
      },
      "entryPoint()": {
        "notice": "return the entryPoint used by this wallet. subclass should return the current entryPoint used by this wallet."
      },
      "exec(address,uint256,bytes)": {
        "notice": "execute a transaction (called directly from owner, not by entryPoint)"
      },
      "execBatch(address[],bytes[])": {
        "notice": "execute a sequence of transaction"
      },
      "getDeposit()": {
        "notice": "check current wallet deposit in the entryPoint"
      },
      "nonce()": {
        "notice": "return the wallet nonce. subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)"
      },
      "transfer(address,uint256)": {
        "notice": "transfer eth value to a destination address"
      },
      "updateEntryPoint(address)": {
        "notice": "expose an api to modify the entryPoint. must be called by current \"admin\" of the wallet."
      },
      "validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,address,bytes,bytes),bytes32,uint256)": {
        "notice": "Validate user's signature and nonce. subclass doesn't override this method. instead, it should override the specific internal validation methods."
      },
      "withdrawDepositTo(address,uint256)": {
        "notice": "withdraw value from the wallet's deposit"
      }
    },
    "notice": "minimal wallet.  this is sample minimal wallet.  has execute, eth handling methods  has a single signer that can send requests through the entryPoint.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4487,
        "contract": "contracts/samples/SimpleWallet.sol:SimpleWallet",
        "label": "_nonce",
        "offset": 0,
        "slot": "0",
        "type": "t_uint96"
      },
      {
        "astId": 4489,
        "contract": "contracts/samples/SimpleWallet.sol:SimpleWallet",
        "label": "owner",
        "offset": 12,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 4511,
        "contract": "contracts/samples/SimpleWallet.sol:SimpleWallet",
        "label": "_entryPoint",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(EntryPoint)3306"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(EntryPoint)3306": {
        "encoding": "inplace",
        "label": "contract EntryPoint",
        "numberOfBytes": "20"
      },
      "t_uint96": {
        "encoding": "inplace",
        "label": "uint96",
        "numberOfBytes": "12"
      }
    }
  }
}