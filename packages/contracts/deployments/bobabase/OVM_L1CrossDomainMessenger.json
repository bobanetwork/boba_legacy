{
  "address": "0xa3e2F30b06130Ee4d563E0F178dfa0F5924CB010",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "msgHash",
          "type": "bytes32"
        }
      ],
      "name": "FailedRelayedMessage",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "_xDomainCalldataHash",
          "type": "bytes32"
        }
      ],
      "name": "MessageAllowed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "_xDomainCalldataHash",
          "type": "bytes32"
        }
      ],
      "name": "MessageBlocked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "msgHash",
          "type": "bytes32"
        }
      ],
      "name": "RelayedMessage",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "messageNonce",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "gasLimit",
          "type": "uint256"
        }
      ],
      "name": "SentMessage",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_xDomainCalldataHash",
          "type": "bytes32"
        }
      ],
      "name": "allowMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_xDomainCalldataHash",
          "type": "bytes32"
        }
      ],
      "name": "blockMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "blockedMessages",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "failedMessages",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_libAddressManager",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "libAddressManager",
      "outputs": [
        {
          "internalType": "contract Lib_AddressManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_messageNonce",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "stateRoot",
              "type": "bytes32"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "batchIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "batchRoot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "batchSize",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "prevTotalElements",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "extraData",
                  "type": "bytes"
                }
              ],
              "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
              "name": "stateRootBatchHeader",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "index",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32[]",
                  "name": "siblings",
                  "type": "bytes32[]"
                }
              ],
              "internalType": "struct Lib_OVMCodec.ChainInclusionProof",
              "name": "stateRootProof",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "stateTrieWitness",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "storageTrieWitness",
              "type": "bytes"
            }
          ],
          "internalType": "struct IL1CrossDomainMessenger.L2MessageInclusionProof",
          "name": "_proof",
          "type": "tuple"
        }
      ],
      "name": "relayMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "relayedMessages",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_queueIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "_oldGasLimit",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "_newGasLimit",
          "type": "uint32"
        }
      ],
      "name": "replayMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "uint32",
          "name": "_gasLimit",
          "type": "uint32"
        }
      ],
      "name": "sendMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "successfulMessages",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "xDomainMessageSender",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x9a8099c5796c32233a2b803c73b480e5219158cb7af760a23dcc6b741eeac6ca",
  "receipt": {
    "to": null,
    "from": "0x02D3535ccA2895b39A261a0BC16aFAA5b178e4E9",
    "contractAddress": "0xa3e2F30b06130Ee4d563E0F178dfa0F5924CB010",
    "transactionIndex": 11,
    "gasUsed": "3403430",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x564771f6300b047382bbebf99bda335b3abe04c16c84add6ceb7c1eeca591a56",
    "transactionHash": "0x9a8099c5796c32233a2b803c73b480e5219158cb7af760a23dcc6b741eeac6ca",
    "logs": [],
    "blockNumber": 2103503,
    "cumulativeGasUsed": "10305227",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "dcdf565a4f7f4cdf231479f0f630b1b7",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"FailedRelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"MessageAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"MessageBlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"RelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"SentMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"allowMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"blockMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"blockedMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"failedMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_messageNonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"stateRootBatchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"stateRootProof\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"stateTrieWitness\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"storageTrieWitness\",\"type\":\"bytes\"}],\"internalType\":\"struct IL1CrossDomainMessenger.L2MessageInclusionProof\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"relayMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"relayedMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_queueIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_oldGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_newGasLimit\",\"type\":\"uint32\"}],\"name\":\"replayMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"successfulMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xDomainMessageSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2 epoch gas limit, it can be resubmitted via this contract's replay function. Runtime target: EVM\",\"kind\":\"dev\",\"methods\":{\"allowMessage(bytes32)\":{\"params\":{\"_xDomainCalldataHash\":\"Hash of the message to allow.\"}},\"blockMessage(bytes32)\":{\"params\":{\"_xDomainCalldataHash\":\"Hash of the message to block.\"}},\"initialize(address)\":{\"params\":{\"_libAddressManager\":\"Address of the Address Manager.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"relayMessage(address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))\":{\"params\":{\"_message\":\"Message to send to the target.\",\"_messageNonce\":\"Nonce for the provided message.\",\"_proof\":\"Inclusion proof for the given message.\",\"_sender\":\"Message sender address.\",\"_target\":\"Target contract address.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"replayMessage(address,address,bytes,uint256,uint32,uint32)\":{\"params\":{\"_message\":\"Message to send to the target.\",\"_newGasLimit\":\"New gas limit to be used for this message.\",\"_oldGasLimit\":\"Original gas limit used to send the message.\",\"_queueIndex\":\"CTC Queue index for the message to replay.\",\"_sender\":\"Original sender address.\",\"_target\":\"Target contract address.\"}},\"resolve(string)\":{\"params\":{\"_name\":\"Name to resolve an address for.\"},\"returns\":{\"_0\":\"Address associated with the given name.\"}},\"sendMessage(address,bytes,uint32)\":{\"params\":{\"_gasLimit\":\"Gas limit for the provided message.\",\"_message\":\"Message to send to the target.\",\"_target\":\"Target contract address.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"L1CrossDomainMessenger\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"allowMessage(bytes32)\":{\"notice\":\"Allow a message.\"},\"blockMessage(bytes32)\":{\"notice\":\"Block a message.\"},\"constructor\":{\"notice\":\"This contract is intended to be behind a delegate proxy. We pass the zero address to the address resolver just to satisfy the constructor. We still need to set this value in initialize().\"},\"pause()\":{\"notice\":\"Pause relaying.\"},\"relayMessage(address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))\":{\"notice\":\"Relays a cross domain message to a contract.\"},\"replayMessage(address,address,bytes,uint256,uint32,uint32)\":{\"notice\":\"Replays a cross domain message to the target messenger.\"},\"resolve(string)\":{\"notice\":\"Resolves the address associated with a given name.\"},\"sendMessage(address,bytes,uint32)\":{\"notice\":\"Sends a cross domain message to the target messenger.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/L1/messaging/L1CrossDomainMessenger.sol\":\"L1CrossDomainMessenger\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x35b09b69aca3bc2633da8f47382a81ecf367efe57167a2114f60f9ec81988afa\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x742c0fbab73bf595ca40025f6e81cb48dbd5e133950717f7befd062a925c0148\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x89fa60d14355f7ae06af11e28fce2bb90c5c6186645d681a30e1b36234a4c210\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x062b5a0f7cc6b0528fa350033759f3a15ba42afb57423d7c593753860f2c82e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"contracts/L1/messaging/IL1CrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { ICrossDomainMessenger } from \\\"../../libraries/bridge/ICrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title IL1CrossDomainMessenger\\n */\\ninterface IL1CrossDomainMessenger is ICrossDomainMessenger {\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    struct L2MessageInclusionProof {\\n        bytes32 stateRoot;\\n        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;\\n        Lib_OVMCodec.ChainInclusionProof stateRootProof;\\n        bytes stateTrieWitness;\\n        bytes storageTrieWitness;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @param _target Target contract address.\\n     * @param _sender Message sender address.\\n     * @param _message Message to send to the target.\\n     * @param _messageNonce Nonce for the provided message.\\n     * @param _proof Inclusion proof for the given message.\\n     */\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce,\\n        L2MessageInclusionProof memory _proof\\n    ) external;\\n\\n    /**\\n     * Replays a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _sender Original sender address.\\n     * @param _message Message to send to the target.\\n     * @param _queueIndex CTC Queue index for the message to replay.\\n     * @param _oldGasLimit Original gas limit used to send the message.\\n     * @param _newGasLimit New gas limit to be used for this message.\\n     */\\n    function replayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _queueIndex,\\n        uint32 _oldGasLimit,\\n        uint32 _newGasLimit\\n    ) external;\\n}\\n\",\"keccak256\":\"0xb0058ed29f6b510f09ffb52dd09812883adccb433cb2da1c8d5dd7de6d6c93ed\",\"license\":\"MIT\"},\"contracts/L1/messaging/L1CrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"../../standards/AddressAliasHelper.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressManager } from \\\"../../libraries/resolver/Lib_AddressManager.sol\\\";\\nimport { Lib_SecureMerkleTrie } from \\\"../../libraries/trie/Lib_SecureMerkleTrie.sol\\\";\\nimport { Lib_DefaultValues } from \\\"../../libraries/constants/Lib_DefaultValues.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\nimport { Lib_CrossDomainUtils } from \\\"../../libraries/bridge/Lib_CrossDomainUtils.sol\\\";\\n\\n/* Interface Imports */\\nimport { IL1CrossDomainMessenger } from \\\"./IL1CrossDomainMessenger.sol\\\";\\nimport { ICanonicalTransactionChain } from \\\"../rollup/ICanonicalTransactionChain.sol\\\";\\nimport { IStateCommitmentChain } from \\\"../rollup/IStateCommitmentChain.sol\\\";\\n\\n/* External Imports */\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport {\\n    PausableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport {\\n    ReentrancyGuardUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/**\\n * @title L1CrossDomainMessenger\\n * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages\\n * from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2\\n * epoch gas limit, it can be resubmitted via this contract's replay function.\\n *\\n * Runtime target: EVM\\n */\\ncontract L1CrossDomainMessenger is\\n    IL1CrossDomainMessenger,\\n    Lib_AddressResolver,\\n    OwnableUpgradeable,\\n    PausableUpgradeable,\\n    ReentrancyGuardUpgradeable\\n{\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event MessageBlocked(bytes32 indexed _xDomainCalldataHash);\\n\\n    event MessageAllowed(bytes32 indexed _xDomainCalldataHash);\\n\\n    /**********************\\n     * Contract Variables *\\n     **********************/\\n\\n    mapping(bytes32 => bool) public blockedMessages;\\n    mapping(bytes32 => bool) public relayedMessages;\\n    mapping(bytes32 => bool) public successfulMessages;\\n    mapping(bytes32 => bool) public failedMessages;\\n\\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * This contract is intended to be behind a delegate proxy.\\n     * We pass the zero address to the address resolver just to satisfy the constructor.\\n     * We still need to set this value in initialize().\\n     */\\n    constructor() Lib_AddressResolver(address(0)) {}\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    function initialize(address _libAddressManager) public initializer {\\n        require(\\n            address(libAddressManager) == address(0),\\n            \\\"L1CrossDomainMessenger already intialized.\\\"\\n        );\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n        // Initialize upgradable OZ contracts\\n        __Context_init_unchained(); // Context is a dependency for both Ownable and Pausable\\n        __Ownable_init_unchained();\\n        __Pausable_init_unchained();\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    /**\\n     * Pause relaying.\\n     */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * Block a message.\\n     * @param _xDomainCalldataHash Hash of the message to block.\\n     */\\n    function blockMessage(bytes32 _xDomainCalldataHash) external onlyOwner {\\n        blockedMessages[_xDomainCalldataHash] = true;\\n        emit MessageBlocked(_xDomainCalldataHash);\\n    }\\n\\n    /**\\n     * Allow a message.\\n     * @param _xDomainCalldataHash Hash of the message to allow.\\n     */\\n    function allowMessage(bytes32 _xDomainCalldataHash) external onlyOwner {\\n        blockedMessages[_xDomainCalldataHash] = false;\\n        emit MessageAllowed(_xDomainCalldataHash);\\n    }\\n\\n    function xDomainMessageSender() public view returns (address) {\\n        require(\\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\\n            \\\"xDomainMessageSender is not set\\\"\\n        );\\n        return xDomainMsgSender;\\n    }\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes memory _message,\\n        uint32 _gasLimit\\n    ) public {\\n        address ovmCanonicalTransactionChain = resolve(\\\"CanonicalTransactionChain\\\");\\n        // Use the CTC queue length as nonce\\n        uint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLength();\\n\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            msg.sender,\\n            _message,\\n            nonce\\n        );\\n\\n        _sendXDomainMessage(ovmCanonicalTransactionChain, xDomainCalldata, _gasLimit);\\n\\n        emit SentMessage(_target, msg.sender, _message, nonce, _gasLimit);\\n    }\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @inheritdoc IL1CrossDomainMessenger\\n     */\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce,\\n        L2MessageInclusionProof memory _proof\\n    ) public nonReentrant whenNotPaused {\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            _sender,\\n            _message,\\n            _messageNonce\\n        );\\n\\n        require(\\n            _verifyXDomainMessage(xDomainCalldata, _proof) == true,\\n            \\\"Provided message could not be verified.\\\"\\n        );\\n\\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\\n\\n        require(\\n            successfulMessages[xDomainCalldataHash] == false,\\n            \\\"Provided message has already been received.\\\"\\n        );\\n\\n        require(\\n            blockedMessages[xDomainCalldataHash] == false,\\n            \\\"Provided message has been blocked.\\\"\\n        );\\n\\n        require(\\n            _target != resolve(\\\"CanonicalTransactionChain\\\"),\\n            \\\"Cannot send L2->L1 messages to L1 system contracts.\\\"\\n        );\\n\\n        xDomainMsgSender = _sender;\\n        (bool success, ) = _target.call(_message);\\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n        // Mark the message as received if the call was successful. Ensures that a message can be\\n        // relayed multiple times in the case that the call reverted.\\n        if (success == true) {\\n            successfulMessages[xDomainCalldataHash] = true;\\n            emit RelayedMessage(xDomainCalldataHash);\\n        } else {\\n            failedMessages[xDomainCalldataHash] = true;\\n            emit FailedRelayedMessage(xDomainCalldataHash);\\n        }\\n\\n        // Store an identifier that can be used to prove that the given message was relayed by some\\n        // user. Gives us an easy way to pay relayers for their work.\\n        bytes32 relayId = keccak256(abi.encodePacked(xDomainCalldata, msg.sender, block.number));\\n        relayedMessages[relayId] = true;\\n    }\\n\\n    /**\\n     * Replays a cross domain message to the target messenger.\\n     * @inheritdoc IL1CrossDomainMessenger\\n     */\\n    function replayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _queueIndex,\\n        uint32 _oldGasLimit,\\n        uint32 _newGasLimit\\n    ) public {\\n        // Verify that the message is in the queue:\\n        address canonicalTransactionChain = resolve(\\\"CanonicalTransactionChain\\\");\\n        Lib_OVMCodec.QueueElement memory element = ICanonicalTransactionChain(\\n            canonicalTransactionChain\\n        ).getQueueElement(_queueIndex);\\n\\n        // Compute the calldata that was originally used to send the message.\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            _sender,\\n            _message,\\n            _queueIndex\\n        );\\n\\n        // Compute the transactionHash\\n        bytes32 transactionHash = keccak256(\\n            abi.encode(\\n                AddressAliasHelper.applyL1ToL2Alias(address(this)),\\n                Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\\n                _oldGasLimit,\\n                xDomainCalldata\\n            )\\n        );\\n\\n        // Now check that the provided message data matches the one in the queue element.\\n        require(\\n            transactionHash == element.transactionHash,\\n            \\\"Provided message has not been enqueued.\\\"\\n        );\\n\\n        // Send the same message but with the new gas limit.\\n        _sendXDomainMessage(canonicalTransactionChain, xDomainCalldata, _newGasLimit);\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Verifies that the given message is valid.\\n     * @param _xDomainCalldata Calldata to verify.\\n     * @param _proof Inclusion proof for the message.\\n     * @return Whether or not the provided message is valid.\\n     */\\n    function _verifyXDomainMessage(\\n        bytes memory _xDomainCalldata,\\n        L2MessageInclusionProof memory _proof\\n    ) internal view returns (bool) {\\n        return (_verifyStateRootProof(_proof) && _verifyStorageProof(_xDomainCalldata, _proof));\\n    }\\n\\n    /**\\n     * Verifies that the state root within an inclusion proof is valid.\\n     * @param _proof Message inclusion proof.\\n     * @return Whether or not the provided proof is valid.\\n     */\\n    function _verifyStateRootProof(L2MessageInclusionProof memory _proof)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        IStateCommitmentChain ovmStateCommitmentChain = IStateCommitmentChain(\\n            resolve(\\\"StateCommitmentChain\\\")\\n        );\\n\\n        return (ovmStateCommitmentChain.insideFraudProofWindow(_proof.stateRootBatchHeader) ==\\n            false &&\\n            ovmStateCommitmentChain.verifyStateCommitment(\\n                _proof.stateRoot,\\n                _proof.stateRootBatchHeader,\\n                _proof.stateRootProof\\n            ));\\n    }\\n\\n    /**\\n     * Verifies that the storage proof within an inclusion proof is valid.\\n     * @param _xDomainCalldata Encoded message calldata.\\n     * @param _proof Message inclusion proof.\\n     * @return Whether or not the provided proof is valid.\\n     */\\n    function _verifyStorageProof(\\n        bytes memory _xDomainCalldata,\\n        L2MessageInclusionProof memory _proof\\n    ) internal view returns (bool) {\\n        bytes32 storageKey = keccak256(\\n            abi.encodePacked(\\n                keccak256(\\n                    abi.encodePacked(\\n                        _xDomainCalldata,\\n                        Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER\\n                    )\\n                ),\\n                uint256(0)\\n            )\\n        );\\n\\n        (bool exists, bytes memory encodedMessagePassingAccount) = Lib_SecureMerkleTrie.get(\\n            abi.encodePacked(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),\\n            _proof.stateTrieWitness,\\n            _proof.stateRoot\\n        );\\n\\n        require(\\n            exists == true,\\n            \\\"Message passing predeploy has not been initialized or invalid proof provided.\\\"\\n        );\\n\\n        Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\\n            encodedMessagePassingAccount\\n        );\\n\\n        return\\n            Lib_SecureMerkleTrie.verifyInclusionProof(\\n                abi.encodePacked(storageKey),\\n                abi.encodePacked(uint8(1)),\\n                _proof.storageTrieWitness,\\n                account.storageRoot\\n            );\\n    }\\n\\n    /**\\n     * Sends a cross domain message.\\n     * @param _canonicalTransactionChain Address of the CanonicalTransactionChain instance.\\n     * @param _message Message to send.\\n     * @param _gasLimit OVM gas limit for the message.\\n     */\\n    function _sendXDomainMessage(\\n        address _canonicalTransactionChain,\\n        bytes memory _message,\\n        uint256 _gasLimit\\n    ) internal {\\n        ICanonicalTransactionChain(_canonicalTransactionChain).enqueue(\\n            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\\n            _gasLimit,\\n            _message\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x1b72a12c13d3c9f198663ae24d74acaa75ae138ca3eac43d69b032c755001655\",\"license\":\"MIT\"},\"contracts/L1/rollup/ICanonicalTransactionChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title ICanonicalTransactionChain\\n */\\ninterface ICanonicalTransactionChain {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event L2GasParamsUpdated(\\n        uint256 l2GasDiscountDivisor,\\n        uint256 enqueueGasCost,\\n        uint256 enqueueL2GasPrepaid\\n    );\\n\\n    event TransactionEnqueued(\\n        address indexed _l1TxOrigin,\\n        address indexed _target,\\n        uint256 _gasLimit,\\n        bytes _data,\\n        uint256 indexed _queueIndex,\\n        uint256 _timestamp\\n    );\\n\\n    event QueueBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event SequencerBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event TransactionBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct BatchContext {\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n    }\\n\\n    /*******************************\\n     * Authorized Setter Functions *\\n     *******************************/\\n\\n    /**\\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\\n     */\\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches() external view returns (IChainStorageContainer);\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue() external view returns (IChainStorageContainer);\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements() external view returns (uint256 _totalElements);\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches() external view returns (uint256 _totalBatches);\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex() external view returns (uint40);\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(uint256 _index)\\n        external\\n        view\\n        returns (Lib_OVMCodec.QueueElement memory _element);\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestamp() external view returns (uint40);\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumber() external view returns (uint40);\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElements() external view returns (uint40);\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength() external view returns (uint40);\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) external;\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch(\\n        // uint40 _shouldStartAtElement,\\n        // uint24 _totalElementsToAppend,\\n        // BatchContext[] _contexts,\\n        // bytes[] _transactionDataFields\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3627ecf85bfcef0c6af5689c720add609be794898e190f176f419eafab46069b\",\"license\":\"MIT\"},\"contracts/L1/rollup/IChainStorageContainer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IChainStorageContainer\\n */\\ninterface IChainStorageContainer {\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata() external view returns (bytes27);\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length() external view returns (uint256);\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(bytes32 _object) external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(uint256 _index) external view returns (bytes32);\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index) external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\\n}\\n\",\"keccak256\":\"0xe55ad72572ec47dc09a02228d0c5a438571c76a41d16d92b35add057811977ce\",\"license\":\"MIT\"},\"contracts/L1/rollup/IStateCommitmentChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title IStateCommitmentChain\\n */\\ninterface IStateCommitmentChain {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event StateBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n    event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements() external view returns (uint256 _totalElements);\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches() external view returns (uint256 _totalBatches);\\n\\n    /**\\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\\n     */\\n    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\\n\\n    /**\\n     * Appends a batch of state roots to the chain.\\n     * @param _batch Batch of state roots.\\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\\n     */\\n    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;\\n\\n    /**\\n     * Deletes all state roots after (and including) a given batch.\\n     * @param _batchHeader Header of the batch to start deleting from.\\n     */\\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;\\n\\n    /**\\n     * Verifies a batch inclusion proof.\\n     * @param _element Hash of the element to verify a proof for.\\n     * @param _batchHeader Header of the batch in which the element was included.\\n     * @param _proof Merkle inclusion proof for the element.\\n     */\\n    function verifyStateCommitment(\\n        bytes32 _element,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _proof\\n    ) external view returns (bool _verified);\\n\\n    /**\\n     * Checks whether a given batch is still inside its fraud proof window.\\n     * @param _batchHeader Header of the batch to check.\\n     * @return _inside Whether or not the batch is inside the fraud proof window.\\n     */\\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n        external\\n        view\\n        returns (bool _inside);\\n}\\n\",\"keccak256\":\"0x47253e63bc34a006102374c39c052470b977e1eb63dacc953e2cbff19940de69\",\"license\":\"MIT\"},\"contracts/libraries/bridge/ICrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(\\n        address indexed target,\\n        address sender,\\n        bytes message,\\n        uint256 messageNonce,\\n        uint256 gasLimit\\n    );\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\",\"keccak256\":\"0x8f29ae23021345a20ccac7b5edb3fc38268aef943b65adc8a32e74b80bf1833a\",\"license\":\"MIT\"},\"contracts/libraries/bridge/Lib_CrossDomainUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\n\\n/**\\n * @title Lib_CrossDomainUtils\\n */\\nlibrary Lib_CrossDomainUtils {\\n    /**\\n     * Generates the correct cross domain calldata for a message.\\n     * @param _target Target contract address.\\n     * @param _sender Message sender address.\\n     * @param _message Message to send to the target.\\n     * @param _messageNonce Nonce for the provided message.\\n     * @return ABI encoded cross domain calldata.\\n     */\\n    function encodeXDomainCalldata(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"relayMessage(address,address,bytes,uint256)\\\",\\n                _target,\\n                _sender,\\n                _message,\\n                _messageNonce\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x6866bf6fb1e32824f58e3cfdeab1220448c4d1130e5ba43c9a060d5c7aae9df1\",\"license\":\"MIT\"},\"contracts/libraries/codec/Lib_OVMCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex; // QUEUED TX ONLY\\n        uint256 timestamp; // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData; // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(Transaction memory _transaction)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                _transaction.timestamp,\\n                _transaction.blockNumber,\\n                _transaction.l1QueueOrigin,\\n                _transaction.l1TxOrigin,\\n                _transaction.entrypoint,\\n                _transaction.gasLimit,\\n                _transaction.data\\n            );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return\\n            EVMAccount({\\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\\n                balance: Lib_RLPReader.readUint256(accountState[1]),\\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n            });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _batchHeader.batchRoot,\\n                    _batchHeader.batchSize,\\n                    _batchHeader.prevTotalElements,\\n                    _batchHeader.extraData\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xb5009ac1e0617e0b3b2fb917f08f8e8a7ae706034cc3a675258bc3d91978525e\",\"license\":\"MIT\"},\"contracts/libraries/constants/Lib_DefaultValues.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_DefaultValues\\n */\\nlibrary Lib_DefaultValues {\\n    // The default x-domain message sender being set to a non-zero value makes\\n    // deployment a bit more expensive, but in exchange the refund on every call to\\n    // `relayMessage` by the L1 and L2 messengers will be higher.\\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\\n}\\n\",\"keccak256\":\"0xa4c6003e04da72f20adb9caed0f8fd3faf5402ad8aa6034e8d9b440e7c0dd227\",\"license\":\"MIT\"},\"contracts/libraries/constants/Lib_PredeployAddresses.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_PredeployAddresses\\n */\\nlibrary Lib_PredeployAddresses {\\n    // solhint-disable max-line-length\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n\\n    // BOBA is the L2 native token\\n    address payable internal constant L2_BOBA = payable(0x4200000000000000000000000000000000000006);\\n    // L1 native token is a ERC20 token on L2\\n    address internal constant L1_NATIVE_TOKEN_L2_ADDRESS =\\n        0x4200000000000000000000000000000000000023;\\n\\n    // solhint-disable-next-line max-line-length\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\\n        0x4200000000000000000000000000000000000007;\\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\\n        0x4200000000000000000000000000000000000012;\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n    address internal constant OVM_GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\\n    address internal constant PROXY__BOBA_TURING_PREPAY =\\n        0x4200000000000000000000000000000000000020;\\n    address internal constant BOBA_TURING_PREPAY = 0x4200000000000000000000000000000000000021;\\n    address internal constant BOBA_TURING_HELPER = 0x4200000000000000000000000000000000000022;\\n    address internal constant PROXY__BOBA_GAS_PRICE_ORACLE =\\n        0x4200000000000000000000000000000000000024;\\n    address internal constant BOBA_GAS_PRICE_ORACLE = 0x4200000000000000000000000000000000000025;\\n}\\n\",\"keccak256\":\"0x237a55927b080be40dd5c261d65bb5d0aa2a153364a588d7183c40997bbf2265\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping(bytes32 => address) private addresses;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0xcde9b29429d512c549f7c1b8a033f161fa71c18cda08b241748663854196ae14\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(address _libAddressManager) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(string memory _name) public view returns (address) {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0x515c4db671a28e2fe180201f6d11c0208c05f582ca3489fb6b8e81c27659bc62\",\"license\":\"MIT\"},\"contracts/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.LIST_ITEM, \\\"Invalid RLP list value.\\\");\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(itemCount < MAX_LIST_LENGTH, \\\"Provided RLP list exceeds max list length.\\\");\\n\\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\\n            );\\n\\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n        return readList(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes value.\\\");\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        return readBytes(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(bytes memory _in) internal pure returns (string memory) {\\n        return readString(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\\n        require(_in.length <= 33, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\\n        return readBytes32(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\\n        return readUint256(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\\n        require(_in.length == 1, \\\"Invalid RLP boolean value.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(out == 0 || out == 1, \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\");\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(bytes memory _in) internal pure returns (bool) {\\n        return readBool(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(_in.length == 21, \\\"Invalid RLP address value.\\\");\\n\\n        return address(uint160(readUint256(_in)));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(bytes memory _in) internal pure returns (address) {\\n        return readAddress(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        return _copy(_in);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(_in.length > 0, \\\"RLP item cannot be null.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(_in.length > strLen, \\\"Invalid RLP short string.\\\");\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(_in.length > lenOfStrLen, \\\"Invalid RLP long string length.\\\");\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\\n            }\\n\\n            require(_in.length > lenOfStrLen + strLen, \\\"Invalid RLP long string.\\\");\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(_in.length > listLen, \\\"Invalid RLP short list.\\\");\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(_in.length > lenOfListLen, \\\"Invalid RLP long list length.\\\");\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\\n            }\\n\\n            require(_in.length > lenOfListLen + listLen, \\\"Invalid RLP long list.\\\");\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    ) private pure returns (bytes memory) {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - (_length % 32)) - 1;\\n        }\\n\\n        assembly {\\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0xde4a27577a23b2b11b21e8af3e1a0df50b0b27f08864795f7a84b1e3c230da33\",\"license\":\"MIT\"},\"contracts/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    ) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0x215b90672ce126effc3f2df61ca0cdf52d2b1cc9be602877e637829b0bf229fd\",\"license\":\"MIT\"},\"contracts/libraries/trie/Lib_MerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\n\\n/**\\n * @title Lib_MerkleTrie\\n */\\nlibrary Lib_MerkleTrie {\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    enum NodeType {\\n        BranchNode,\\n        ExtensionNode,\\n        LeafNode\\n    }\\n\\n    struct TrieNode {\\n        bytes encoded;\\n        Lib_RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /**********************\\n     * Contract Constants *\\n     **********************/\\n\\n    // TREE_RADIX determines the number of elements per branch node.\\n    uint256 constant TREE_RADIX = 16;\\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    // Prefixes are prepended to the `path` within a leaf or extension node and\\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\\n    // determined by the number of nibbles within the unprefixed `path`. If the\\n    // number of nibbles if even, we need to insert an extra padding nibble so\\n    // the resulting prefixed `path` has an even number of nibbles.\\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\\n    uint8 constant PREFIX_LEAF_EVEN = 2;\\n    uint8 constant PREFIX_LEAF_ODD = 3;\\n\\n    // Just a utility constant. RLP represents `NULL` as 0x80.\\n    bytes1 constant RLP_NULL = bytes1(0x80);\\n    bytes constant RLP_NULL_BYTES = hex\\\"80\\\";\\n    bytes32 internal constant KECCAK256_RLP_NULL_BYTES = keccak256(RLP_NULL_BYTES);\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _verified) {\\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\\n\\n        return (exists && Lib_BytesUtils.equal(_value, value));\\n    }\\n\\n    /**\\n     * @notice Updates a Merkle trie and returns a new root hash.\\n     * @param _key Key of the node to update, as a hex string.\\n     * @param _value Value of the node to update, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n     * target node. If the key exists, we can simply update the value.\\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _updatedRoot Root hash of the newly constructed trie.\\n     */\\n    function update(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bytes32 _updatedRoot) {\\n        // Special case when inserting the very first node.\\n        if (_root == KECCAK256_RLP_NULL_BYTES) {\\n            return getSingleNodeRootHash(_key, _value);\\n        }\\n\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        (uint256 pathLength, bytes memory keyRemainder, ) = _walkNodePath(proof, _key, _root);\\n        TrieNode[] memory newPath = _getNewPath(proof, pathLength, _key, keyRemainder, _value);\\n\\n        return _getUpdatedTrieRoot(newPath, _key);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _exists, bytes memory _value) {\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\\n            proof,\\n            _key,\\n            _root\\n        );\\n\\n        bool exists = keyRemainder.length == 0;\\n\\n        require(exists || isFinalNode, \\\"Provided proof is invalid.\\\");\\n\\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\\\"\\\");\\n\\n        return (exists, value);\\n    }\\n\\n    /**\\n     * Computes the root hash for a trie with a single node.\\n     * @param _key Key for the single node.\\n     * @param _value Value for the single node.\\n     * @return _updatedRoot Hash of the trie.\\n     */\\n    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\\n        internal\\n        pure\\n        returns (bytes32 _updatedRoot)\\n    {\\n        return keccak256(_makeLeafNode(Lib_BytesUtils.toNibbles(_key), _value).encoded);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * @notice Walks through a proof using a provided key.\\n     * @param _proof Inclusion proof to walk through.\\n     * @param _key Key to use for the walk.\\n     * @param _root Known root of the trie.\\n     * @return _pathLength Length of the final path\\n     * @return _keyRemainder Portion of the key remaining after the walk.\\n     * @return _isFinalNode Whether or not we've hit a dead end.\\n     */\\n    function _walkNodePath(\\n        TrieNode[] memory _proof,\\n        bytes memory _key,\\n        bytes32 _root\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256 _pathLength,\\n            bytes memory _keyRemainder,\\n            bool _isFinalNode\\n        )\\n    {\\n        uint256 pathLength = 0;\\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n        bytes32 currentNodeID = _root;\\n        uint256 currentKeyIndex = 0;\\n        uint256 currentKeyIncrement = 0;\\n        TrieNode memory currentNode;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < _proof.length; i++) {\\n            currentNode = _proof[i];\\n            currentKeyIndex += currentKeyIncrement;\\n\\n            // Keep track of the proof elements we actually need.\\n            // It's expensive to resize arrays, so this simply reduces gas costs.\\n            pathLength += 1;\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(keccak256(currentNode.encoded) == currentNodeID, \\\"Invalid root hash\\\");\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    keccak256(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 31 bytes aren't hashed.\\n                require(\\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid internal node hash\\\"\\n                );\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // We've hit the end of the key\\n                    // meaning the value should be within this branch node.\\n                    break;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIncrement = 1;\\n                    continue;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    if (\\n                        pathRemainder.length == sharedNibbleLength &&\\n                        keyRemainder.length == sharedNibbleLength\\n                    ) {\\n                        // The key within this leaf matches our key exactly.\\n                        // Increment the key index to reflect that we have no remainder.\\n                        currentKeyIndex += sharedNibbleLength;\\n                    }\\n\\n                    // We've hit a leaf node, so our next node should be NULL.\\n                    currentNodeID = bytes32(RLP_NULL);\\n                    break;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    if (sharedNibbleLength != pathRemainder.length) {\\n                        // Our extension node is not identical to the remainder.\\n                        // We've hit the end of this path\\n                        // updates will need to modify this extension.\\n                        currentNodeID = bytes32(RLP_NULL);\\n                        break;\\n                    } else {\\n                        // Our extension shares some nibbles.\\n                        // Carry on to the next node.\\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                        currentKeyIncrement = sharedNibbleLength;\\n                        continue;\\n                    }\\n                } else {\\n                    revert(\\\"Received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"Received an unparseable node.\\\");\\n            }\\n        }\\n\\n        // If our node ID is NULL, then we're at a dead end.\\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\\n    }\\n\\n    /**\\n     * @notice Creates new nodes to support a k/v pair insertion into a given Merkle trie path.\\n     * @param _path Path to the node nearest the k/v pair.\\n     * @param _pathLength Length of the path. Necessary because the provided path may include\\n     *  additional nodes (e.g., it comes directly from a proof) and we can't resize in-memory\\n     *  arrays without costly duplication.\\n     * @param _key Full original key.\\n     * @param _keyRemainder Portion of the initial key that must be inserted into the trie.\\n     * @param _value Value to insert at the given key.\\n     * @return _newPath A new path with the inserted k/v pair and extra supporting nodes.\\n     */\\n    function _getNewPath(\\n        TrieNode[] memory _path,\\n        uint256 _pathLength,\\n        bytes memory _key,\\n        bytes memory _keyRemainder,\\n        bytes memory _value\\n    ) private pure returns (TrieNode[] memory _newPath) {\\n        bytes memory keyRemainder = _keyRemainder;\\n\\n        // Most of our logic depends on the status of the last node in the path.\\n        TrieNode memory lastNode = _path[_pathLength - 1];\\n        NodeType lastNodeType = _getNodeType(lastNode);\\n\\n        // Create an array for newly created nodes.\\n        // We need up to three new nodes, depending on the contents of the last node.\\n        // Since array resizing is expensive, we'll keep track of the size manually.\\n        // We're using an explicit `totalNewNodes += 1` after insertions for clarity.\\n        TrieNode[] memory newNodes = new TrieNode[](3);\\n        uint256 totalNewNodes = 0;\\n\\n        // solhint-disable-next-line max-line-length\\n        // Reference: https://github.com/ethereumjs/merkle-patricia-tree/blob/c0a10395aab37d42c175a47114ebfcbd7efcf059/src/baseTrie.ts#L294-L313\\n        bool matchLeaf = false;\\n        if (lastNodeType == NodeType.LeafNode) {\\n            uint256 l = 0;\\n            if (_path.length > 0) {\\n                for (uint256 i = 0; i < _path.length - 1; i++) {\\n                    if (_getNodeType(_path[i]) == NodeType.BranchNode) {\\n                        l++;\\n                    } else {\\n                        l += _getNodeKey(_path[i]).length;\\n                    }\\n                }\\n            }\\n\\n            if (\\n                _getSharedNibbleLength(\\n                    _getNodeKey(lastNode),\\n                    Lib_BytesUtils.slice(Lib_BytesUtils.toNibbles(_key), l)\\n                ) ==\\n                _getNodeKey(lastNode).length &&\\n                keyRemainder.length == 0\\n            ) {\\n                matchLeaf = true;\\n            }\\n        }\\n\\n        if (matchLeaf) {\\n            // We've found a leaf node with the given key.\\n            // Simply need to update the value of the node to match.\\n            newNodes[totalNewNodes] = _makeLeafNode(_getNodeKey(lastNode), _value);\\n            totalNewNodes += 1;\\n        } else if (lastNodeType == NodeType.BranchNode) {\\n            if (keyRemainder.length == 0) {\\n                // We've found a branch node with the given key.\\n                // Simply need to update the value of the node to match.\\n                newNodes[totalNewNodes] = _editBranchValue(lastNode, _value);\\n                totalNewNodes += 1;\\n            } else {\\n                // We've found a branch node, but it doesn't contain our key.\\n                // Reinsert the old branch for now.\\n                newNodes[totalNewNodes] = lastNode;\\n                totalNewNodes += 1;\\n                // Create a new leaf node, slicing our remainder since the first byte points\\n                // to our branch node.\\n                newNodes[totalNewNodes] = _makeLeafNode(\\n                    Lib_BytesUtils.slice(keyRemainder, 1),\\n                    _value\\n                );\\n                totalNewNodes += 1;\\n            }\\n        } else {\\n            // Our last node is either an extension node or a leaf node with a different key.\\n            bytes memory lastNodeKey = _getNodeKey(lastNode);\\n            uint256 sharedNibbleLength = _getSharedNibbleLength(lastNodeKey, keyRemainder);\\n\\n            if (sharedNibbleLength != 0) {\\n                // We've got some shared nibbles between the last node and our key remainder.\\n                // We'll need to insert an extension node that covers these shared nibbles.\\n                bytes memory nextNodeKey = Lib_BytesUtils.slice(lastNodeKey, 0, sharedNibbleLength);\\n                newNodes[totalNewNodes] = _makeExtensionNode(nextNodeKey, _getNodeHash(_value));\\n                totalNewNodes += 1;\\n\\n                // Cut down the keys since we've just covered these shared nibbles.\\n                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, sharedNibbleLength);\\n                keyRemainder = Lib_BytesUtils.slice(keyRemainder, sharedNibbleLength);\\n            }\\n\\n            // Create an empty branch to fill in.\\n            TrieNode memory newBranch = _makeEmptyBranchNode();\\n\\n            if (lastNodeKey.length == 0) {\\n                // Key remainder was larger than the key for our last node.\\n                // The value within our last node is therefore going to be shifted into\\n                // a branch value slot.\\n                newBranch = _editBranchValue(newBranch, _getNodeValue(lastNode));\\n            } else {\\n                // Last node key was larger than the key remainder.\\n                // We're going to modify some index of our branch.\\n                uint8 branchKey = uint8(lastNodeKey[0]);\\n                // Move on to the next nibble.\\n                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, 1);\\n\\n                if (lastNodeType == NodeType.LeafNode) {\\n                    // We're dealing with a leaf node.\\n                    // We'll modify the key and insert the old leaf node into the branch index.\\n                    TrieNode memory modifiedLastNode = _makeLeafNode(\\n                        lastNodeKey,\\n                        _getNodeValue(lastNode)\\n                    );\\n                    newBranch = _editBranchIndex(\\n                        newBranch,\\n                        branchKey,\\n                        _getNodeHash(modifiedLastNode.encoded)\\n                    );\\n                } else if (lastNodeKey.length != 0) {\\n                    // We're dealing with a shrinking extension node.\\n                    // We need to modify the node to decrease the size of the key.\\n                    TrieNode memory modifiedLastNode = _makeExtensionNode(\\n                        lastNodeKey,\\n                        _getNodeValue(lastNode)\\n                    );\\n                    newBranch = _editBranchIndex(\\n                        newBranch,\\n                        branchKey,\\n                        _getNodeHash(modifiedLastNode.encoded)\\n                    );\\n                } else {\\n                    // We're dealing with an unnecessary extension node.\\n                    // We're going to delete the node entirely.\\n                    // Simply insert its current value into the branch index.\\n                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeValue(lastNode));\\n                }\\n            }\\n\\n            if (keyRemainder.length == 0) {\\n                // We've got nothing left in the key remainder.\\n                // Simply insert the value into the branch value slot.\\n                newBranch = _editBranchValue(newBranch, _value);\\n                // Push the branch into the list of new nodes.\\n                newNodes[totalNewNodes] = newBranch;\\n                totalNewNodes += 1;\\n            } else {\\n                // We've got some key remainder to work with.\\n                // We'll be inserting a leaf node into the trie.\\n                // First, move on to the next nibble.\\n                keyRemainder = Lib_BytesUtils.slice(keyRemainder, 1);\\n                // Push the branch into the list of new nodes.\\n                newNodes[totalNewNodes] = newBranch;\\n                totalNewNodes += 1;\\n                // Push a new leaf node for our k/v pair.\\n                newNodes[totalNewNodes] = _makeLeafNode(keyRemainder, _value);\\n                totalNewNodes += 1;\\n            }\\n        }\\n\\n        // Finally, join the old path with our newly created nodes.\\n        // Since we're overwriting the last node in the path, we use `_pathLength - 1`.\\n        return _joinNodeArrays(_path, _pathLength - 1, newNodes, totalNewNodes);\\n    }\\n\\n    /**\\n     * @notice Computes the trie root from a given path.\\n     * @param _nodes Path to some k/v pair.\\n     * @param _key Key for the k/v pair.\\n     * @return _updatedRoot Root hash for the updated trie.\\n     */\\n    function _getUpdatedTrieRoot(TrieNode[] memory _nodes, bytes memory _key)\\n        private\\n        pure\\n        returns (bytes32 _updatedRoot)\\n    {\\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n        // Some variables to keep track of during iteration.\\n        TrieNode memory currentNode;\\n        NodeType currentNodeType;\\n        bytes memory previousNodeHash;\\n\\n        // Run through the path backwards to rebuild our root hash.\\n        for (uint256 i = _nodes.length; i > 0; i--) {\\n            // Pick out the current node.\\n            currentNode = _nodes[i - 1];\\n            currentNodeType = _getNodeType(currentNode);\\n\\n            if (currentNodeType == NodeType.LeafNode) {\\n                // Leaf nodes are already correctly encoded.\\n                // Shift the key over to account for the nodes key.\\n                bytes memory nodeKey = _getNodeKey(currentNode);\\n                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\\n            } else if (currentNodeType == NodeType.ExtensionNode) {\\n                // Shift the key over to account for the nodes key.\\n                bytes memory nodeKey = _getNodeKey(currentNode);\\n                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\\n\\n                // If this node is the last element in the path, it'll be correctly encoded\\n                // and we can skip this part.\\n                if (previousNodeHash.length > 0) {\\n                    // Re-encode the node based on the previous node.\\n                    currentNode = _editExtensionNodeValue(currentNode, previousNodeHash);\\n                }\\n            } else if (currentNodeType == NodeType.BranchNode) {\\n                // If this node is the last element in the path, it'll be correctly encoded\\n                // and we can skip this part.\\n                if (previousNodeHash.length > 0) {\\n                    // Re-encode the node based on the previous node.\\n                    uint8 branchKey = uint8(key[key.length - 1]);\\n                    key = Lib_BytesUtils.slice(key, 0, key.length - 1);\\n                    currentNode = _editBranchIndex(currentNode, branchKey, previousNodeHash);\\n                }\\n            }\\n\\n            // Compute the node hash for the next iteration.\\n            previousNodeHash = _getNodeHash(currentNode.encoded);\\n        }\\n\\n        // Current node should be the root at this point.\\n        // Simply return the hash of its encoding.\\n        return keccak256(currentNode.encoded);\\n    }\\n\\n    /**\\n     * @notice Parses an RLP-encoded proof into something more useful.\\n     * @param _proof RLP-encoded proof to parse.\\n     * @return _parsed Proof parsed into easily accessible structs.\\n     */\\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\\n\\n        for (uint256 i = 0; i < nodes.length; i++) {\\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\\n            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\\n        }\\n\\n        return proof;\\n    }\\n\\n    /**\\n     * @notice Picks out the ID for a node. Node ID is referred to as the\\n     * \\\"hash\\\" within the specification, but nodes < 32 bytes are not actually\\n     * hashed.\\n     * @param _node Node to pull an ID for.\\n     * @return _nodeID ID for the node, depending on the size of its contents.\\n     */\\n    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\\n        bytes memory nodeID;\\n\\n        if (_node.length < 32) {\\n            // Nodes smaller than 32 bytes are RLP encoded.\\n            nodeID = Lib_RLPReader.readRawBytes(_node);\\n        } else {\\n            // Nodes 32 bytes or larger are hashed.\\n            nodeID = Lib_RLPReader.readBytes(_node);\\n        }\\n\\n        return Lib_BytesUtils.toBytes32(nodeID);\\n    }\\n\\n    /**\\n     * @notice Gets the path for a leaf or extension node.\\n     * @param _node Node to get a path for.\\n     * @return _path Node path, converted to an array of nibbles.\\n     */\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /**\\n     * @notice Gets the key for a leaf or extension node. Keys are essentially\\n     * just paths without any prefix.\\n     * @param _node Node to get a key for.\\n     * @return _key Node key, converted to an array of nibbles.\\n     */\\n    function _getNodeKey(TrieNode memory _node) private pure returns (bytes memory _key) {\\n        return _removeHexPrefix(_getNodePath(_node));\\n    }\\n\\n    /**\\n     * @notice Gets the path for a node.\\n     * @param _node Node to get a value for.\\n     * @return _value Node value, as hex bytes.\\n     */\\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\\n    }\\n\\n    /**\\n     * @notice Computes the node hash for an encoded node. Nodes < 32 bytes\\n     * are not hashed, all others are keccak256 hashed.\\n     * @param _encoded Encoded node to hash.\\n     * @return _hash Hash of the encoded node. Simply the input if < 32 bytes.\\n     */\\n    function _getNodeHash(bytes memory _encoded) private pure returns (bytes memory _hash) {\\n        if (_encoded.length < 32) {\\n            return _encoded;\\n        } else {\\n            return abi.encodePacked(keccak256(_encoded));\\n        }\\n    }\\n\\n    /**\\n     * @notice Determines the type for a given node.\\n     * @param _node Node to determine a type for.\\n     * @return _type Type of the node; BranchNode/ExtensionNode/LeafNode.\\n     */\\n    function _getNodeType(TrieNode memory _node) private pure returns (NodeType _type) {\\n        if (_node.decoded.length == BRANCH_NODE_LENGTH) {\\n            return NodeType.BranchNode;\\n        } else if (_node.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n            bytes memory path = _getNodePath(_node);\\n            uint8 prefix = uint8(path[0]);\\n\\n            if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                return NodeType.LeafNode;\\n            } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                return NodeType.ExtensionNode;\\n            }\\n        }\\n\\n        revert(\\\"Invalid node type\\\");\\n    }\\n\\n    /**\\n     * @notice Utility; determines the number of nibbles shared between two\\n     * nibble arrays.\\n     * @param _a First nibble array.\\n     * @param _b Second nibble array.\\n     * @return _shared Number of shared nibbles.\\n     */\\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\\n        private\\n        pure\\n        returns (uint256 _shared)\\n    {\\n        uint256 i = 0;\\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    /**\\n     * @notice Utility; converts an RLP-encoded node into our nice struct.\\n     * @param _raw RLP-encoded node to convert.\\n     * @return _node Node as a TrieNode struct.\\n     */\\n    function _makeNode(bytes[] memory _raw) private pure returns (TrieNode memory _node) {\\n        bytes memory encoded = Lib_RLPWriter.writeList(_raw);\\n\\n        return TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\\n    }\\n\\n    /**\\n     * @notice Utility; converts an RLP-decoded node into our nice struct.\\n     * @param _items RLP-decoded node to convert.\\n     * @return _node Node as a TrieNode struct.\\n     */\\n    function _makeNode(Lib_RLPReader.RLPItem[] memory _items)\\n        private\\n        pure\\n        returns (TrieNode memory _node)\\n    {\\n        bytes[] memory raw = new bytes[](_items.length);\\n        for (uint256 i = 0; i < _items.length; i++) {\\n            raw[i] = Lib_RLPReader.readRawBytes(_items[i]);\\n        }\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Creates a new extension node.\\n     * @param _key Key for the extension node, unprefixed.\\n     * @param _value Value for the extension node.\\n     * @return _node New extension node with the given k/v pair.\\n     */\\n    function _makeExtensionNode(bytes memory _key, bytes memory _value)\\n        private\\n        pure\\n        returns (TrieNode memory _node)\\n    {\\n        bytes[] memory raw = new bytes[](2);\\n        bytes memory key = _addHexPrefix(_key, false);\\n        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n        raw[1] = Lib_RLPWriter.writeBytes(_value);\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * Creates a new extension node with the same key but a different value.\\n     * @param _node Extension node to copy and modify.\\n     * @param _value New value for the extension node.\\n     * @return New node with the same key and different value.\\n     */\\n    function _editExtensionNodeValue(TrieNode memory _node, bytes memory _value)\\n        private\\n        pure\\n        returns (TrieNode memory)\\n    {\\n        bytes[] memory raw = new bytes[](2);\\n        bytes memory key = _addHexPrefix(_getNodeKey(_node), false);\\n        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n        if (_value.length < 32) {\\n            raw[1] = _value;\\n        } else {\\n            raw[1] = Lib_RLPWriter.writeBytes(_value);\\n        }\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Creates a new leaf node.\\n     * @dev This function is essentially identical to `_makeExtensionNode`.\\n     * Although we could route both to a single method with a flag, it's\\n     * more gas efficient to keep them separate and duplicate the logic.\\n     * @param _key Key for the leaf node, unprefixed.\\n     * @param _value Value for the leaf node.\\n     * @return _node New leaf node with the given k/v pair.\\n     */\\n    function _makeLeafNode(bytes memory _key, bytes memory _value)\\n        private\\n        pure\\n        returns (TrieNode memory _node)\\n    {\\n        bytes[] memory raw = new bytes[](2);\\n        bytes memory key = _addHexPrefix(_key, true);\\n        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n        raw[1] = Lib_RLPWriter.writeBytes(_value);\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Creates an empty branch node.\\n     * @return _node Empty branch node as a TrieNode struct.\\n     */\\n    function _makeEmptyBranchNode() private pure returns (TrieNode memory _node) {\\n        bytes[] memory raw = new bytes[](BRANCH_NODE_LENGTH);\\n        for (uint256 i = 0; i < raw.length; i++) {\\n            raw[i] = RLP_NULL_BYTES;\\n        }\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Modifies the value slot for a given branch.\\n     * @param _branch Branch node to modify.\\n     * @param _value Value to insert into the branch.\\n     * @return _updatedNode Modified branch node.\\n     */\\n    function _editBranchValue(TrieNode memory _branch, bytes memory _value)\\n        private\\n        pure\\n        returns (TrieNode memory _updatedNode)\\n    {\\n        bytes memory encoded = Lib_RLPWriter.writeBytes(_value);\\n        _branch.decoded[_branch.decoded.length - 1] = Lib_RLPReader.toRLPItem(encoded);\\n        return _makeNode(_branch.decoded);\\n    }\\n\\n    /**\\n     * @notice Modifies a slot at an index for a given branch.\\n     * @param _branch Branch node to modify.\\n     * @param _index Slot index to modify.\\n     * @param _value Value to insert into the slot.\\n     * @return _updatedNode Modified branch node.\\n     */\\n    function _editBranchIndex(\\n        TrieNode memory _branch,\\n        uint8 _index,\\n        bytes memory _value\\n    ) private pure returns (TrieNode memory _updatedNode) {\\n        bytes memory encoded = _value.length < 32 ? _value : Lib_RLPWriter.writeBytes(_value);\\n        _branch.decoded[_index] = Lib_RLPReader.toRLPItem(encoded);\\n        return _makeNode(_branch.decoded);\\n    }\\n\\n    /**\\n     * @notice Utility; adds a prefix to a key.\\n     * @param _key Key to prefix.\\n     * @param _isLeaf Whether or not the key belongs to a leaf.\\n     * @return _prefixedKey Prefixed key.\\n     */\\n    function _addHexPrefix(bytes memory _key, bool _isLeaf)\\n        private\\n        pure\\n        returns (bytes memory _prefixedKey)\\n    {\\n        uint8 prefix = _isLeaf ? uint8(0x02) : uint8(0x00);\\n        uint8 offset = uint8(_key.length % 2);\\n        bytes memory prefixed = new bytes(2 - offset);\\n        prefixed[0] = bytes1(prefix + offset);\\n        return abi.encodePacked(prefixed, _key);\\n    }\\n\\n    /**\\n     * @notice Utility; removes a prefix from a path.\\n     * @param _path Path to remove the prefix from.\\n     * @return _unprefixedKey Unprefixed key.\\n     */\\n    function _removeHexPrefix(bytes memory _path)\\n        private\\n        pure\\n        returns (bytes memory _unprefixedKey)\\n    {\\n        if (uint8(_path[0]) % 2 == 0) {\\n            return Lib_BytesUtils.slice(_path, 2);\\n        } else {\\n            return Lib_BytesUtils.slice(_path, 1);\\n        }\\n    }\\n\\n    /**\\n     * @notice Utility; combines two node arrays. Array lengths are required\\n     * because the actual lengths may be longer than the filled lengths.\\n     * Array resizing is extremely costly and should be avoided.\\n     * @param _a First array to join.\\n     * @param _aLength Length of the first array.\\n     * @param _b Second array to join.\\n     * @param _bLength Length of the second array.\\n     * @return _joined Combined node array.\\n     */\\n    function _joinNodeArrays(\\n        TrieNode[] memory _a,\\n        uint256 _aLength,\\n        TrieNode[] memory _b,\\n        uint256 _bLength\\n    ) private pure returns (TrieNode[] memory _joined) {\\n        TrieNode[] memory ret = new TrieNode[](_aLength + _bLength);\\n\\n        // Copy elements from the first array.\\n        for (uint256 i = 0; i < _aLength; i++) {\\n            ret[i] = _a[i];\\n        }\\n\\n        // Copy elements from the second array.\\n        for (uint256 i = 0; i < _bLength; i++) {\\n            ret[i + _aLength] = _b[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n\",\"keccak256\":\"0xf74792249e96247fdcd4f91ff472e9bc29c4fba5d651696c5b769c71d0a49db2\",\"license\":\"MIT\"},\"contracts/libraries/trie/Lib_SecureMerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_MerkleTrie } from \\\"./Lib_MerkleTrie.sol\\\";\\n\\n/**\\n * @title Lib_SecureMerkleTrie\\n */\\nlibrary Lib_SecureMerkleTrie {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _verified) {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Updates a Merkle trie and returns a new root hash.\\n     * @param _key Key of the node to update, as a hex string.\\n     * @param _value Value of the node to update, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n     * target node. If the key exists, we can simply update the value.\\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _updatedRoot Root hash of the newly constructed trie.\\n     */\\n    function update(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bytes32 _updatedRoot) {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.update(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _exists, bytes memory _value) {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /**\\n     * Computes the root hash for a trie with a single node.\\n     * @param _key Key for the single node.\\n     * @param _value Value for the single node.\\n     * @return _updatedRoot Hash of the trie.\\n     */\\n    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\\n        internal\\n        pure\\n        returns (bytes32 _updatedRoot)\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.getSingleNodeRootHash(key, _value);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Computes the secure counterpart to a key.\\n     * @param _key Key to get a secure key from.\\n     * @return _secureKey Secure version of the key.\\n     */\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\\n        return abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\",\"keccak256\":\"0x8a5898637aebe30794e954d9749f6d62963e4e387e773bde5b06d0aecdc2ac23\",\"license\":\"MIT\"},\"contracts/libraries/utils/Lib_Bytes32Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(bytes32 _in) internal pure returns (bool) {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(bool _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(bytes32 _in) internal pure returns (address) {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(address _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_in)));\\n    }\\n}\\n\",\"keccak256\":\"0xf2d1a526f2529e51fc2fffccf093c1691e291cbbb6de8a3da7d7f80024a9a234\",\"license\":\"MIT\"},\"contracts/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0xc39ee13f97e4ccfbc72a5aac571deb3c1aff882fca2dd18be794d43ac5de0a30\",\"license\":\"MIT\"},\"contracts/standards/AddressAliasHelper.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.7;\\n\\nlibrary AddressAliasHelper {\\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + offset);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - offset);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf330061b0ad081dd4d35a3efaeb3acd0a926c23ebb1ce7115007dac406d61b3f\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405260cd80546001600160a01b03191661dead17905534801561002457600080fd5b50600080546001600160a01b0319169055613c7e806100446000396000f3fe608060405234801561001057600080fd5b50600436106101365760003560e01c806381ada46c116100b2578063b1b1b20911610081578063c6b94ab011610066578063c6b94ab0146102b3578063d7fd19dd146102d6578063f2fde38b146102e957600080fd5b8063b1b1b2091461027d578063c4d66de8146102a057600080fd5b806381ada46c146102215780638456cb59146102345780638da5cb5b1461023c578063a4e7f8bd1461025a57600080fd5b8063461a4478116101095780636e296e45116100ee5780636e296e45146101fe5780636f1c8d4714610206578063715018a61461021957600080fd5b8063461a4478146101e05780635c975abb146101f357600080fd5b80630ecf2eea1461013b57806321d800ec14610150578063299ca478146101885780633dbb202b146101cd575b600080fd5b61014e610149366004613170565b6102fc565b005b61017361015e366004613170565b60ca6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b6000546101a89073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161017f565b61014e6101db3660046132e8565b6103ab565b6101a86101ee366004613348565b6104f3565b60655460ff16610173565b6101a86105a0565b61014e610214366004613399565b61062a565b61014e610811565b61014e61022f366004613170565b610884565b61014e61092b565b60335473ffffffffffffffffffffffffffffffffffffffff166101a8565b610173610268366004613170565b60cc6020526000908152604090205460ff1681565b61017361028b366004613170565b60cb6020526000908152604090205460ff1681565b61014e6102ae366004613425565b61099a565b6101736102c1366004613170565b60c96020526000908152604090205460ff1681565b61014e6102e436600461358b565b610be7565b61014e6102f7366004613425565b6110cb565b60335473ffffffffffffffffffffffffffffffffffffffff1633146103685760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b600081815260c96020526040808220805460ff191660011790555182917ff52508d5339edf0d7e5060a416df98db067af561bdc60872d29c0439eaa13a0291a250565b60006103eb6040518060400160405280601981526020017f43616e6f6e6963616c5472616e73616374696f6e436861696e000000000000008152506104f3565b905060008173ffffffffffffffffffffffffffffffffffffffff1663b8f770056040518163ffffffff1660e01b815260040160206040518083038186803b15801561043557600080fd5b505afa158015610449573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046d91906136d9565b905060006104848633878564ffffffffff166111c7565b905061049783828663ffffffff16611242565b8573ffffffffffffffffffffffffffffffffffffffff167fcb0f7ffd78f9aee47a248fae8db181db6eee833039123e026dcbff529522e52a338785886040516104e39493929190613750565b60405180910390a2505050505050565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac19061054a9085906004016137a3565b60206040518083038186803b15801561056257600080fd5b505afa158015610576573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061059a91906137b6565b92915050565b60cd5460009073ffffffffffffffffffffffffffffffffffffffff1661dead141561060d5760405162461bcd60e51b815260206004820152601f60248201527f78446f6d61696e4d65737361676553656e646572206973206e6f742073657400604482015260640161035f565b5060cd5473ffffffffffffffffffffffffffffffffffffffff1690565b600061066a6040518060400160405280601981526020017f43616e6f6e6963616c5472616e73616374696f6e436861696e000000000000008152506104f3565b6040517f2a7f18be0000000000000000000000000000000000000000000000000000000081526004810186905290915060009073ffffffffffffffffffffffffffffffffffffffff831690632a7f18be9060240160606040518083038186803b1580156106d657600080fd5b505afa1580156106ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070e91906137d3565b9050600061071e898989896111c7565b90506000731111000000000000000000000000000000001111300173420000000000000000000000000000000000000787846040516020016107639493929190613838565b604051602081830303815290604052805190602001209050826000015181146107f45760405162461bcd60e51b815260206004820152602760248201527f50726f7669646564206d65737361676520686173206e6f74206265656e20656e60448201527f7175657565642e00000000000000000000000000000000000000000000000000606482015260840161035f565b61080584838763ffffffff16611242565b50505050505050505050565b60335473ffffffffffffffffffffffffffffffffffffffff1633146108785760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b61088260006112e3565b565b60335473ffffffffffffffffffffffffffffffffffffffff1633146108eb5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b600081815260c96020526040808220805460ff191690555182917f52c8a2680a9f4cc0ad0bf88f32096eadbebf0646ea611d93a0ce6a29a024040591a250565b60335473ffffffffffffffffffffffffffffffffffffffff1633146109925760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b61088261135a565b6000547501000000000000000000000000000000000000000000900460ff16806109df575060005474010000000000000000000000000000000000000000900460ff16155b610a515760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff16158015610ab857600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b60005473ffffffffffffffffffffffffffffffffffffffff1615610b445760405162461bcd60e51b815260206004820152602a60248201527f4c3143726f7373446f6d61696e4d657373656e67657220616c7265616479206960448201527f6e7469616c697a65642e00000000000000000000000000000000000000000000606482015260840161035f565b6000805473ffffffffffffffffffffffffffffffffffffffff84167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915560cd805490911661dead179055610b9c61140c565b610ba461155b565b610bac611682565b610bb46117db565b8015610be357600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff1690555b5050565b60026097541415610c3a5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161035f565b600260975560655460ff1615610c925760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a2070617573656400000000000000000000000000000000604482015260640161035f565b6000610ca0868686866111c7565b9050610cac818361192f565b1515600114610d235760405162461bcd60e51b815260206004820152602760248201527f50726f7669646564206d65737361676520636f756c64206e6f7420626520766560448201527f7269666965642e00000000000000000000000000000000000000000000000000606482015260840161035f565b8051602080830191909120600081815260cb90925260409091205460ff1615610db45760405162461bcd60e51b815260206004820152602b60248201527f50726f7669646564206d6573736167652068617320616c72656164792062656560448201527f6e2072656365697665642e000000000000000000000000000000000000000000606482015260840161035f565b600081815260c9602052604090205460ff1615610e395760405162461bcd60e51b815260206004820152602260248201527f50726f7669646564206d65737361676520686173206265656e20626c6f636b6560448201527f642e000000000000000000000000000000000000000000000000000000000000606482015260840161035f565b610e776040518060400160405280601981526020017f43616e6f6e6963616c5472616e73616374696f6e436861696e000000000000008152506104f3565b73ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff161415610f185760405162461bcd60e51b815260206004820152603360248201527f43616e6e6f742073656e64204c322d3e4c31206d6573736167657320746f204c60448201527f312073797374656d20636f6e7472616374732e00000000000000000000000000606482015260840161035f565b60cd80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff88811691909117909155604051600091891690610f7190889061387d565b6000604051808303816000865af19150503d8060008114610fae576040519150601f19603f3d011682016040523d82523d6000602084013e610fb3565b606091505b505060cd80547fffffffffffffffffffffffff00000000000000000000000000000000000000001661dead17905590508015156001141561103357600082815260cb6020526040808220805460ff191660011790555183917f4641df4a962071e12719d8c8c8e5ac7fc4d97b927346a3d7a335b1f7517e133c91a2611074565b600082815260cc6020526040808220805460ff191660011790555183917f99d0e048484baa1b1540b1367cb128acd7ab2946d1ed91ec10e3c85e4bf51b8f91a25b600083334360405160200161108b93929190613899565b60408051601f198184030181529181528151602092830120600090815260ca9092529020805460ff19166001908117909155609755505050505050505050565b60335473ffffffffffffffffffffffffffffffffffffffff1633146111325760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b73ffffffffffffffffffffffffffffffffffffffff81166111bb5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161035f565b6111c4816112e3565b50565b6060848484846040516024016111e094939291906138eb565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fcbd4ece9000000000000000000000000000000000000000000000000000000001790529050949350505050565b6040517f6fee07e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff841690636fee07e0906112ac907342000000000000000000000000000000000000079085908790600401613935565b600060405180830381600087803b1580156112c657600080fd5b505af11580156112da573d6000803e3d6000fd5b50505050505050565b6033805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60655460ff16156113ad5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a2070617573656400000000000000000000000000000000604482015260640161035f565b6065805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586113e23390565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390a1565b6000547501000000000000000000000000000000000000000000900460ff1680611451575060005474010000000000000000000000000000000000000000900460ff16155b6114c35760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff1615801561152a57600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b80156111c457600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff16905550565b6000547501000000000000000000000000000000000000000000900460ff16806115a0575060005474010000000000000000000000000000000000000000900460ff16155b6116125760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff1615801561167957600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b61152a336112e3565b6000547501000000000000000000000000000000000000000000900460ff16806116c7575060005474010000000000000000000000000000000000000000900460ff16155b6117395760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff161580156117a057600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b6065805460ff1916905580156111c457600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff16905550565b6000547501000000000000000000000000000000000000000000900460ff1680611820575060005474010000000000000000000000000000000000000000900460ff16155b6118925760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff161580156118f957600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b600160975580156111c457600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff16905550565b600061193a82611952565b801561194b575061194b8383611af4565b9392505050565b6000806119936040518060400160405280601481526020017f5374617465436f6d6d69746d656e74436861696e0000000000000000000000008152506104f3565b60208401516040517f9418bddd00000000000000000000000000000000000000000000000000000000815291925073ffffffffffffffffffffffffffffffffffffffff831691639418bddd916119eb916004016139a7565b60206040518083038186803b158015611a0357600080fd5b505afa158015611a17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a3b91906139ba565b15801561194b57508251602084015160408086015190517f4d69ee5700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851693634d69ee5793611aa49391929091906004016139dc565b60206040518083038186803b158015611abc57600080fd5b505afa158015611ad0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194b91906139ba565b60008083734200000000000000000000000000000000000007604051602001611b1e929190613a54565b60408051601f1981840301815282825280516020918201209083015260009082015260600160408051601f198184030181529082905280516020918201207f42000000000000000000000000000000000000000000000000000000000000009183019190915291506000908190611bae9060340160408051601f1981840301815291905260608701518751611cd8565b9092509050600182151514611c515760405162461bcd60e51b815260206004820152604d60248201527f4d6573736167652070617373696e67207072656465706c6f7920686173206e6f60448201527f74206265656e20696e697469616c697a6564206f7220696e76616c696420707260648201527f6f6f662070726f76696465642e00000000000000000000000000000000000000608482015260a40161035f565b6000611c5c82611d01565b9050611ccd84604051602001611c7491815260200190565b60408051601f19818403018152908290527f010000000000000000000000000000000000000000000000000000000000000060208301529060210160405160208183030381529060405288608001518460400151611dc5565b979650505050505050565b600060606000611ce786611de9565b9050611cf4818686611e1b565b9250925050935093915050565b604080516080810182526000808252602082018190529181018290526060810182905290611d2e83611ef6565b90506040518060800160405280611d5e83600081518110611d5157611d51613a9e565b6020026020010151611f29565b8152602001611d7983600181518110611d5157611d51613a9e565b8152602001611da183600281518110611d9457611d94613a9e565b6020026020010151611f30565b8152602001611dbc83600381518110611d9457611d94613a9e565b90529392505050565b600080611dd186611de9565b9050611ddf81868686612032565b9695505050505050565b60608180519060200120604051602001611e0591815260200190565b6040516020818303038152906040529050919050565b600060606000611e2a85612068565b90506000806000611e3c848a89612163565b81519295509093509150158080611e505750815b611e9c5760405162461bcd60e51b815260206004820152601a60248201527f50726f76696465642070726f6f6620697320696e76616c69642e000000000000604482015260640161035f565b600081611eb85760405180602001604052806000815250611ee4565b611ee486611ec7600188613afc565b81518110611ed757611ed7613a9e565b60200260200101516125fe565b919b919a509098505050505050505050565b60408051808201825260008082526020918201528151808301909252825182528083019082015260609061059a90612628565b600061059a825b6000602182600001511115611f875760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420524c5020627974657333322076616c75652e000000000000604482015260640161035f565b6000806000611f9585612827565b919450925090506000816001811115611fb057611fb0613b13565b14611ffd5760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420524c5020627974657333322076616c75652e000000000000604482015260640161035f565b600083866020015161200f9190613b42565b80519091506020841015611ddf5760208490036101000a90049695505050505050565b6000806000612042878686611e1b565b91509150818015611ccd5750805160208083019190912087519188019190912014611ccd565b6060600061207583611ef6565b90506000815167ffffffffffffffff811115612093576120936131ab565b6040519080825280602002602001820160405280156120d857816020015b60408051808201909152606080825260208201528152602001906001900390816120b15790505b50905060005b825181101561215b57600061210b8483815181106120fe576120fe613a9e565b6020026020010151612b78565b9050604051806040016040528082815260200161212783611ef6565b81525083838151811061213c5761213c613a9e565b602002602001018190525050808061215390613b5a565b9150506120de565b509392505050565b6000606081808061217387612c08565b9050600086905060008061219a604051806040016040528060608152602001606081525090565b60005b8c518110156125ba578c81815181106121b8576121b8613a9e565b6020026020010151915082846121ce9190613b42565b93506121db600188613b42565b96508361223f5781518051602090910120851461223a5760405162461bcd60e51b815260206004820152601160248201527f496e76616c696420726f6f742068617368000000000000000000000000000000604482015260640161035f565b6122fc565b8151516020116122a15781518051602090910120851461223a5760405162461bcd60e51b815260206004820152601b60248201527f496e76616c6964206c6172676520696e7465726e616c20686173680000000000604482015260640161035f565b846122af8360000151612d8b565b146122fc5760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420696e7465726e616c206e6f64652068617368000000000000604482015260640161035f565b61230860106001613b42565b8260200151511415612381578551841415612322576125ba565b600086858151811061233657612336613a9e565b602001015160f81c60f81b60f81c9050600083602001518260ff168151811061236157612361613a9e565b6020026020010151905061237481612db3565b96506001945050506125a8565b6002826020015151141561256057600061239a83612de9565b90506000816000815181106123b1576123b1613a9e565b016020015160f81c905060006123c8600283613bc2565b6123d3906002613be4565b905060006123e4848360ff16612e0d565b905060006123f28b8a612e0d565b905060006124008383612e43565b905060ff851660021480612417575060ff85166003145b1561246d5780835114801561242c5750808251145b1561243e5761243b818b613b42565b99505b507f800000000000000000000000000000000000000000000000000000000000000099506125ba945050505050565b60ff85161580612480575060ff85166001145b156124f257825181146124bc57507f800000000000000000000000000000000000000000000000000000000000000099506125ba945050505050565b6124e388602001516001815181106124d6576124d6613a9e565b6020026020010151612db3565b9a5097506125a8945050505050565b60405162461bcd60e51b815260206004820152602660248201527f52656365697665642061206e6f6465207769746820616e20756e6b6e6f776e2060448201527f7072656669780000000000000000000000000000000000000000000000000000606482015260840161035f565b60405162461bcd60e51b815260206004820152601d60248201527f526563656976656420616e20756e706172736561626c65206e6f64652e000000604482015260640161035f565b806125b281613b5a565b91505061219d565b507f80000000000000000000000000000000000000000000000000000000000000008414866125e98786612e0d565b909e909d50909b509950505050505050505050565b6020810151805160609161059a9161261890600190613afc565b815181106120fe576120fe613a9e565b606060008061263684612827565b9193509091506001905081600181111561265257612652613b13565b1461269f5760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420524c50206c6973742076616c75652e000000000000000000604482015260640161035f565b6040805160208082526104208201909252600091816020015b60408051808201909152600080825260208201528152602001906001900390816126b85790505090506000835b865181101561281c57602082106127645760405162461bcd60e51b815260206004820152602a60248201527f50726f766964656420524c50206c6973742065786365656473206d6178206c6960448201527f7374206c656e6774682e00000000000000000000000000000000000000000000606482015260840161035f565b6000806127a16040518060400160405280858c600001516127859190613afc565b8152602001858c6020015161279a9190613b42565b9052612827565b5091509150604051806040016040528083836127bd9190613b42565b8152602001848b602001516127d29190613b42565b8152508585815181106127e7576127e7613a9e565b60209081029190910101526127fd600185613b42565b93506128098183613b42565b6128139084613b42565b925050506126e5565b508152949350505050565b60008060008084600001511161287f5760405162461bcd60e51b815260206004820152601860248201527f524c50206974656d2063616e6e6f74206265206e756c6c2e0000000000000000604482015260640161035f565b6020840151805160001a607f81116128a4576000600160009450945094505050612b71565b60b781116129205760006128b9608083613afc565b90508087600001511161290e5760405162461bcd60e51b815260206004820152601960248201527f496e76616c696420524c502073686f727420737472696e672e00000000000000604482015260640161035f565b60019550935060009250612b71915050565b60bf8111612a0f57600061293560b783613afc565b90508087600001511161298a5760405162461bcd60e51b815260206004820152601f60248201527f496e76616c696420524c50206c6f6e6720737472696e67206c656e6774682e00604482015260640161035f565b600183015160208290036101000a90046129a48183613b42565b8851116129f35760405162461bcd60e51b815260206004820152601860248201527f496e76616c696420524c50206c6f6e6720737472696e672e0000000000000000604482015260640161035f565b6129fe826001613b42565b9650945060009350612b7192505050565b60f78111612a8a576000612a2460c083613afc565b905080876000015111612a795760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420524c502073686f7274206c6973742e000000000000000000604482015260640161035f565b600195509350849250612b71915050565b6000612a9760f783613afc565b905080876000015111612aec5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c696420524c50206c6f6e67206c697374206c656e6774682e000000604482015260640161035f565b600183015160208290036101000a9004612b068183613b42565b885111612b555760405162461bcd60e51b815260206004820152601660248201527f496e76616c696420524c50206c6f6e67206c6973742e00000000000000000000604482015260640161035f565b612b60826001613b42565b9650945060019350612b7192505050565b9193909250565b60606000806000612b8885612827565b919450925090506000816001811115612ba357612ba3613b13565b14612bf05760405162461bcd60e51b815260206004820152601860248201527f496e76616c696420524c502062797465732076616c75652e0000000000000000604482015260640161035f565b612bff85602001518484612eef565b95945050505050565b6060600082516002612c1a9190613c07565b67ffffffffffffffff811115612c3257612c326131ab565b6040519080825280601f01601f191660200182016040528015612c5c576020820181803683370190505b50905060005b8351811015612d84576004848281518110612c7f57612c7f613a9e565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016901c82612cb4836002613c07565b81518110612cc457612cc4613a9e565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506010848281518110612d0757612d07613a9e565b0160200151612d19919060f81c613bc2565b60f81b82612d28836002613c07565b612d33906001613b42565b81518110612d4357612d43613a9e565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080612d7c81613b5a565b915050612c62565b5092915050565b6000602082511015612d9f57506020015190565b8180602001905181019061059a9190613c44565b60006060602083600001511015612dd457612dcd83612fce565b9050612de0565b612ddd83612b78565b90505b61194b81612d8b565b606061059a612e0883602001516000815181106120fe576120fe613a9e565b612c08565b606082518210612e2c575060408051602081019091526000815261059a565b61194b8383848651612e3e9190613afc565b612fd9565b6000805b808451118015612e575750808351115b8015612ed85750828181518110612e7057612e70613a9e565b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916848281518110612eaf57612eaf613a9e565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016145b1561194b5780612ee781613b5a565b915050612e47565b606060008267ffffffffffffffff811115612f0c57612f0c6131ab565b6040519080825280601f01601f191660200182016040528015612f36576020820181803683370190505b509050805160001415612f4a57905061194b565b6000612f568587613b42565b90506020820160005b612f6a602087613c5d565b811015612fa15782518252612f80602084613b42565b9250612f8d602083613b42565b915080612f9981613b5a565b915050612f5f565b5060006001602087066020036101000a039050808251168119845116178252839450505050509392505050565b606061059a8261315a565b606081612fe781601f613b42565b10156130355760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015260640161035f565b826130408382613b42565b101561308e5760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015260640161035f565b6130988284613b42565b845110156130e85760405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015260640161035f565b6060821580156131075760405191506000825260208201604052613151565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015613140578051835260209283019201613128565b5050858452601f01601f1916604052505b50949350505050565b606061059a826020015160008460000151612eef565b60006020828403121561318257600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff811681146111c457600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156131fd576131fd6131ab565b60405290565b60405160a0810167ffffffffffffffff811182821017156131fd576131fd6131ab565b604051601f8201601f1916810167ffffffffffffffff8111828210171561324f5761324f6131ab565b604052919050565b600067ffffffffffffffff831115613271576132716131ab565b6132846020601f19601f86011601613226565b905082815283838301111561329857600080fd5b828260208301376000602084830101529392505050565b600082601f8301126132c057600080fd5b61194b83833560208501613257565b803563ffffffff811681146132e357600080fd5b919050565b6000806000606084860312156132fd57600080fd5b833561330881613189565b9250602084013567ffffffffffffffff81111561332457600080fd5b613330868287016132af565b92505061333f604085016132cf565b90509250925092565b60006020828403121561335a57600080fd5b813567ffffffffffffffff81111561337157600080fd5b8201601f8101841361338257600080fd5b61339184823560208401613257565b949350505050565b60008060008060008060c087890312156133b257600080fd5b86356133bd81613189565b955060208701356133cd81613189565b9450604087013567ffffffffffffffff8111156133e957600080fd5b6133f589828a016132af565b9450506060870135925061340b608088016132cf565b915061341960a088016132cf565b90509295509295509295565b60006020828403121561343757600080fd5b813561194b81613189565b600060a0828403121561345457600080fd5b60405160a0810167ffffffffffffffff8282108183111715613478576134786131ab565b816040528293508435835260208501356020840152604085013560408401526060850135606084015260808501359150808211156134b557600080fd5b506134c2858286016132af565b6080830152505092915050565b6000604082840312156134e157600080fd5b6134e96131da565b90508135815260208083013567ffffffffffffffff8082111561350b57600080fd5b818501915085601f83011261351f57600080fd5b813581811115613531576135316131ab565b8060051b9150613542848301613226565b818152918301840191848101908884111561355c57600080fd5b938501935b8385101561357a57843582529385019390850190613561565b808688015250505050505092915050565b600080600080600060a086880312156135a357600080fd5b85356135ae81613189565b945060208601356135be81613189565b9350604086013567ffffffffffffffff808211156135db57600080fd5b6135e789838a016132af565b945060608801359350608088013591508082111561360457600080fd5b9087019060a0828a03121561361857600080fd5b613620613203565b8235815260208301358281111561363657600080fd5b6136428b828601613442565b60208301525060408301358281111561365a57600080fd5b6136668b8286016134cf565b60408301525060608301358281111561367e57600080fd5b61368a8b8286016132af565b6060830152506080830135828111156136a257600080fd5b6136ae8b8286016132af565b6080830152508093505050509295509295909350565b805164ffffffffff811681146132e357600080fd5b6000602082840312156136eb57600080fd5b61194b826136c4565b60005b8381101561370f5781810151838201526020016136f7565b8381111561371e576000848401525b50505050565b6000815180845261373c8160208601602086016136f4565b601f01601f19169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff8516815260806020820152600061377f6080830186613724565b905064ffffffffff8416604083015263ffffffff8316606083015295945050505050565b60208152600061194b6020830184613724565b6000602082840312156137c857600080fd5b815161194b81613189565b6000606082840312156137e557600080fd5b6040516060810181811067ffffffffffffffff82111715613808576138086131ab565b6040528251815261381b602084016136c4565b602082015261382c604084016136c4565b60408201529392505050565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525063ffffffff8416604083015260806060830152611ddf6080830184613724565b6000825161388f8184602087016136f4565b9190910192915050565b600084516138ab8184602089016136f4565b60609490941b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001691909301908152601481019190915260340192915050565b600073ffffffffffffffffffffffffffffffffffffffff8087168352808616602084015250608060408301526139246080830185613724565b905082606083015295945050505050565b73ffffffffffffffffffffffffffffffffffffffff84168152826020820152606060408201526000612bff6060830184613724565b805182526020810151602083015260408101516040830152606081015160608301526000608082015160a0608085015261339160a0850182613724565b60208152600061194b602083018461396a565b6000602082840312156139cc57600080fd5b8151801515811461194b57600080fd5b838152600060206060818401526139f6606084018661396a565b83810360408501526040810185518252828601516040848401528181518084526060850191508583019450600093505b80841015613a465784518252938501936001939093019290850190613a26565b509998505050505050505050565b60008351613a668184602088016136f4565b60609390931b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169190920190815260140192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082821015613b0e57613b0e613acd565b500390565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60008219821115613b5557613b55613acd565b500190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613b8c57613b8c613acd565b5060010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600060ff831680613bd557613bd5613b93565b8060ff84160691505092915050565b600060ff821660ff841680821015613bfe57613bfe613acd565b90039392505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615613c3f57613c3f613acd565b500290565b600060208284031215613c5657600080fd5b5051919050565b600082613c6c57613c6c613b93565b50049056fea164736f6c6343000809000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101365760003560e01c806381ada46c116100b2578063b1b1b20911610081578063c6b94ab011610066578063c6b94ab0146102b3578063d7fd19dd146102d6578063f2fde38b146102e957600080fd5b8063b1b1b2091461027d578063c4d66de8146102a057600080fd5b806381ada46c146102215780638456cb59146102345780638da5cb5b1461023c578063a4e7f8bd1461025a57600080fd5b8063461a4478116101095780636e296e45116100ee5780636e296e45146101fe5780636f1c8d4714610206578063715018a61461021957600080fd5b8063461a4478146101e05780635c975abb146101f357600080fd5b80630ecf2eea1461013b57806321d800ec14610150578063299ca478146101885780633dbb202b146101cd575b600080fd5b61014e610149366004613170565b6102fc565b005b61017361015e366004613170565b60ca6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b6000546101a89073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161017f565b61014e6101db3660046132e8565b6103ab565b6101a86101ee366004613348565b6104f3565b60655460ff16610173565b6101a86105a0565b61014e610214366004613399565b61062a565b61014e610811565b61014e61022f366004613170565b610884565b61014e61092b565b60335473ffffffffffffffffffffffffffffffffffffffff166101a8565b610173610268366004613170565b60cc6020526000908152604090205460ff1681565b61017361028b366004613170565b60cb6020526000908152604090205460ff1681565b61014e6102ae366004613425565b61099a565b6101736102c1366004613170565b60c96020526000908152604090205460ff1681565b61014e6102e436600461358b565b610be7565b61014e6102f7366004613425565b6110cb565b60335473ffffffffffffffffffffffffffffffffffffffff1633146103685760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b600081815260c96020526040808220805460ff191660011790555182917ff52508d5339edf0d7e5060a416df98db067af561bdc60872d29c0439eaa13a0291a250565b60006103eb6040518060400160405280601981526020017f43616e6f6e6963616c5472616e73616374696f6e436861696e000000000000008152506104f3565b905060008173ffffffffffffffffffffffffffffffffffffffff1663b8f770056040518163ffffffff1660e01b815260040160206040518083038186803b15801561043557600080fd5b505afa158015610449573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046d91906136d9565b905060006104848633878564ffffffffff166111c7565b905061049783828663ffffffff16611242565b8573ffffffffffffffffffffffffffffffffffffffff167fcb0f7ffd78f9aee47a248fae8db181db6eee833039123e026dcbff529522e52a338785886040516104e39493929190613750565b60405180910390a2505050505050565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac19061054a9085906004016137a3565b60206040518083038186803b15801561056257600080fd5b505afa158015610576573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061059a91906137b6565b92915050565b60cd5460009073ffffffffffffffffffffffffffffffffffffffff1661dead141561060d5760405162461bcd60e51b815260206004820152601f60248201527f78446f6d61696e4d65737361676553656e646572206973206e6f742073657400604482015260640161035f565b5060cd5473ffffffffffffffffffffffffffffffffffffffff1690565b600061066a6040518060400160405280601981526020017f43616e6f6e6963616c5472616e73616374696f6e436861696e000000000000008152506104f3565b6040517f2a7f18be0000000000000000000000000000000000000000000000000000000081526004810186905290915060009073ffffffffffffffffffffffffffffffffffffffff831690632a7f18be9060240160606040518083038186803b1580156106d657600080fd5b505afa1580156106ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070e91906137d3565b9050600061071e898989896111c7565b90506000731111000000000000000000000000000000001111300173420000000000000000000000000000000000000787846040516020016107639493929190613838565b604051602081830303815290604052805190602001209050826000015181146107f45760405162461bcd60e51b815260206004820152602760248201527f50726f7669646564206d65737361676520686173206e6f74206265656e20656e60448201527f7175657565642e00000000000000000000000000000000000000000000000000606482015260840161035f565b61080584838763ffffffff16611242565b50505050505050505050565b60335473ffffffffffffffffffffffffffffffffffffffff1633146108785760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b61088260006112e3565b565b60335473ffffffffffffffffffffffffffffffffffffffff1633146108eb5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b600081815260c96020526040808220805460ff191690555182917f52c8a2680a9f4cc0ad0bf88f32096eadbebf0646ea611d93a0ce6a29a024040591a250565b60335473ffffffffffffffffffffffffffffffffffffffff1633146109925760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b61088261135a565b6000547501000000000000000000000000000000000000000000900460ff16806109df575060005474010000000000000000000000000000000000000000900460ff16155b610a515760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff16158015610ab857600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b60005473ffffffffffffffffffffffffffffffffffffffff1615610b445760405162461bcd60e51b815260206004820152602a60248201527f4c3143726f7373446f6d61696e4d657373656e67657220616c7265616479206960448201527f6e7469616c697a65642e00000000000000000000000000000000000000000000606482015260840161035f565b6000805473ffffffffffffffffffffffffffffffffffffffff84167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915560cd805490911661dead179055610b9c61140c565b610ba461155b565b610bac611682565b610bb46117db565b8015610be357600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff1690555b5050565b60026097541415610c3a5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161035f565b600260975560655460ff1615610c925760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a2070617573656400000000000000000000000000000000604482015260640161035f565b6000610ca0868686866111c7565b9050610cac818361192f565b1515600114610d235760405162461bcd60e51b815260206004820152602760248201527f50726f7669646564206d65737361676520636f756c64206e6f7420626520766560448201527f7269666965642e00000000000000000000000000000000000000000000000000606482015260840161035f565b8051602080830191909120600081815260cb90925260409091205460ff1615610db45760405162461bcd60e51b815260206004820152602b60248201527f50726f7669646564206d6573736167652068617320616c72656164792062656560448201527f6e2072656365697665642e000000000000000000000000000000000000000000606482015260840161035f565b600081815260c9602052604090205460ff1615610e395760405162461bcd60e51b815260206004820152602260248201527f50726f7669646564206d65737361676520686173206265656e20626c6f636b6560448201527f642e000000000000000000000000000000000000000000000000000000000000606482015260840161035f565b610e776040518060400160405280601981526020017f43616e6f6e6963616c5472616e73616374696f6e436861696e000000000000008152506104f3565b73ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff161415610f185760405162461bcd60e51b815260206004820152603360248201527f43616e6e6f742073656e64204c322d3e4c31206d6573736167657320746f204c60448201527f312073797374656d20636f6e7472616374732e00000000000000000000000000606482015260840161035f565b60cd80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff88811691909117909155604051600091891690610f7190889061387d565b6000604051808303816000865af19150503d8060008114610fae576040519150601f19603f3d011682016040523d82523d6000602084013e610fb3565b606091505b505060cd80547fffffffffffffffffffffffff00000000000000000000000000000000000000001661dead17905590508015156001141561103357600082815260cb6020526040808220805460ff191660011790555183917f4641df4a962071e12719d8c8c8e5ac7fc4d97b927346a3d7a335b1f7517e133c91a2611074565b600082815260cc6020526040808220805460ff191660011790555183917f99d0e048484baa1b1540b1367cb128acd7ab2946d1ed91ec10e3c85e4bf51b8f91a25b600083334360405160200161108b93929190613899565b60408051601f198184030181529181528151602092830120600090815260ca9092529020805460ff19166001908117909155609755505050505050505050565b60335473ffffffffffffffffffffffffffffffffffffffff1633146111325760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161035f565b73ffffffffffffffffffffffffffffffffffffffff81166111bb5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161035f565b6111c4816112e3565b50565b6060848484846040516024016111e094939291906138eb565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fcbd4ece9000000000000000000000000000000000000000000000000000000001790529050949350505050565b6040517f6fee07e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff841690636fee07e0906112ac907342000000000000000000000000000000000000079085908790600401613935565b600060405180830381600087803b1580156112c657600080fd5b505af11580156112da573d6000803e3d6000fd5b50505050505050565b6033805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60655460ff16156113ad5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a2070617573656400000000000000000000000000000000604482015260640161035f565b6065805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586113e23390565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390a1565b6000547501000000000000000000000000000000000000000000900460ff1680611451575060005474010000000000000000000000000000000000000000900460ff16155b6114c35760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff1615801561152a57600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b80156111c457600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff16905550565b6000547501000000000000000000000000000000000000000000900460ff16806115a0575060005474010000000000000000000000000000000000000000900460ff16155b6116125760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff1615801561167957600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b61152a336112e3565b6000547501000000000000000000000000000000000000000000900460ff16806116c7575060005474010000000000000000000000000000000000000000900460ff16155b6117395760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff161580156117a057600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b6065805460ff1916905580156111c457600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff16905550565b6000547501000000000000000000000000000000000000000000900460ff1680611820575060005474010000000000000000000000000000000000000000900460ff16155b6118925760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161035f565b6000547501000000000000000000000000000000000000000000900460ff161580156118f957600080547fffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff1675010100000000000000000000000000000000000000001790555b600160975580156111c457600080547fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff16905550565b600061193a82611952565b801561194b575061194b8383611af4565b9392505050565b6000806119936040518060400160405280601481526020017f5374617465436f6d6d69746d656e74436861696e0000000000000000000000008152506104f3565b60208401516040517f9418bddd00000000000000000000000000000000000000000000000000000000815291925073ffffffffffffffffffffffffffffffffffffffff831691639418bddd916119eb916004016139a7565b60206040518083038186803b158015611a0357600080fd5b505afa158015611a17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a3b91906139ba565b15801561194b57508251602084015160408086015190517f4d69ee5700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851693634d69ee5793611aa49391929091906004016139dc565b60206040518083038186803b158015611abc57600080fd5b505afa158015611ad0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194b91906139ba565b60008083734200000000000000000000000000000000000007604051602001611b1e929190613a54565b60408051601f1981840301815282825280516020918201209083015260009082015260600160408051601f198184030181529082905280516020918201207f42000000000000000000000000000000000000000000000000000000000000009183019190915291506000908190611bae9060340160408051601f1981840301815291905260608701518751611cd8565b9092509050600182151514611c515760405162461bcd60e51b815260206004820152604d60248201527f4d6573736167652070617373696e67207072656465706c6f7920686173206e6f60448201527f74206265656e20696e697469616c697a6564206f7220696e76616c696420707260648201527f6f6f662070726f76696465642e00000000000000000000000000000000000000608482015260a40161035f565b6000611c5c82611d01565b9050611ccd84604051602001611c7491815260200190565b60408051601f19818403018152908290527f010000000000000000000000000000000000000000000000000000000000000060208301529060210160405160208183030381529060405288608001518460400151611dc5565b979650505050505050565b600060606000611ce786611de9565b9050611cf4818686611e1b565b9250925050935093915050565b604080516080810182526000808252602082018190529181018290526060810182905290611d2e83611ef6565b90506040518060800160405280611d5e83600081518110611d5157611d51613a9e565b6020026020010151611f29565b8152602001611d7983600181518110611d5157611d51613a9e565b8152602001611da183600281518110611d9457611d94613a9e565b6020026020010151611f30565b8152602001611dbc83600381518110611d9457611d94613a9e565b90529392505050565b600080611dd186611de9565b9050611ddf81868686612032565b9695505050505050565b60608180519060200120604051602001611e0591815260200190565b6040516020818303038152906040529050919050565b600060606000611e2a85612068565b90506000806000611e3c848a89612163565b81519295509093509150158080611e505750815b611e9c5760405162461bcd60e51b815260206004820152601a60248201527f50726f76696465642070726f6f6620697320696e76616c69642e000000000000604482015260640161035f565b600081611eb85760405180602001604052806000815250611ee4565b611ee486611ec7600188613afc565b81518110611ed757611ed7613a9e565b60200260200101516125fe565b919b919a509098505050505050505050565b60408051808201825260008082526020918201528151808301909252825182528083019082015260609061059a90612628565b600061059a825b6000602182600001511115611f875760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420524c5020627974657333322076616c75652e000000000000604482015260640161035f565b6000806000611f9585612827565b919450925090506000816001811115611fb057611fb0613b13565b14611ffd5760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420524c5020627974657333322076616c75652e000000000000604482015260640161035f565b600083866020015161200f9190613b42565b80519091506020841015611ddf5760208490036101000a90049695505050505050565b6000806000612042878686611e1b565b91509150818015611ccd5750805160208083019190912087519188019190912014611ccd565b6060600061207583611ef6565b90506000815167ffffffffffffffff811115612093576120936131ab565b6040519080825280602002602001820160405280156120d857816020015b60408051808201909152606080825260208201528152602001906001900390816120b15790505b50905060005b825181101561215b57600061210b8483815181106120fe576120fe613a9e565b6020026020010151612b78565b9050604051806040016040528082815260200161212783611ef6565b81525083838151811061213c5761213c613a9e565b602002602001018190525050808061215390613b5a565b9150506120de565b509392505050565b6000606081808061217387612c08565b9050600086905060008061219a604051806040016040528060608152602001606081525090565b60005b8c518110156125ba578c81815181106121b8576121b8613a9e565b6020026020010151915082846121ce9190613b42565b93506121db600188613b42565b96508361223f5781518051602090910120851461223a5760405162461bcd60e51b815260206004820152601160248201527f496e76616c696420726f6f742068617368000000000000000000000000000000604482015260640161035f565b6122fc565b8151516020116122a15781518051602090910120851461223a5760405162461bcd60e51b815260206004820152601b60248201527f496e76616c6964206c6172676520696e7465726e616c20686173680000000000604482015260640161035f565b846122af8360000151612d8b565b146122fc5760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420696e7465726e616c206e6f64652068617368000000000000604482015260640161035f565b61230860106001613b42565b8260200151511415612381578551841415612322576125ba565b600086858151811061233657612336613a9e565b602001015160f81c60f81b60f81c9050600083602001518260ff168151811061236157612361613a9e565b6020026020010151905061237481612db3565b96506001945050506125a8565b6002826020015151141561256057600061239a83612de9565b90506000816000815181106123b1576123b1613a9e565b016020015160f81c905060006123c8600283613bc2565b6123d3906002613be4565b905060006123e4848360ff16612e0d565b905060006123f28b8a612e0d565b905060006124008383612e43565b905060ff851660021480612417575060ff85166003145b1561246d5780835114801561242c5750808251145b1561243e5761243b818b613b42565b99505b507f800000000000000000000000000000000000000000000000000000000000000099506125ba945050505050565b60ff85161580612480575060ff85166001145b156124f257825181146124bc57507f800000000000000000000000000000000000000000000000000000000000000099506125ba945050505050565b6124e388602001516001815181106124d6576124d6613a9e565b6020026020010151612db3565b9a5097506125a8945050505050565b60405162461bcd60e51b815260206004820152602660248201527f52656365697665642061206e6f6465207769746820616e20756e6b6e6f776e2060448201527f7072656669780000000000000000000000000000000000000000000000000000606482015260840161035f565b60405162461bcd60e51b815260206004820152601d60248201527f526563656976656420616e20756e706172736561626c65206e6f64652e000000604482015260640161035f565b806125b281613b5a565b91505061219d565b507f80000000000000000000000000000000000000000000000000000000000000008414866125e98786612e0d565b909e909d50909b509950505050505050505050565b6020810151805160609161059a9161261890600190613afc565b815181106120fe576120fe613a9e565b606060008061263684612827565b9193509091506001905081600181111561265257612652613b13565b1461269f5760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420524c50206c6973742076616c75652e000000000000000000604482015260640161035f565b6040805160208082526104208201909252600091816020015b60408051808201909152600080825260208201528152602001906001900390816126b85790505090506000835b865181101561281c57602082106127645760405162461bcd60e51b815260206004820152602a60248201527f50726f766964656420524c50206c6973742065786365656473206d6178206c6960448201527f7374206c656e6774682e00000000000000000000000000000000000000000000606482015260840161035f565b6000806127a16040518060400160405280858c600001516127859190613afc565b8152602001858c6020015161279a9190613b42565b9052612827565b5091509150604051806040016040528083836127bd9190613b42565b8152602001848b602001516127d29190613b42565b8152508585815181106127e7576127e7613a9e565b60209081029190910101526127fd600185613b42565b93506128098183613b42565b6128139084613b42565b925050506126e5565b508152949350505050565b60008060008084600001511161287f5760405162461bcd60e51b815260206004820152601860248201527f524c50206974656d2063616e6e6f74206265206e756c6c2e0000000000000000604482015260640161035f565b6020840151805160001a607f81116128a4576000600160009450945094505050612b71565b60b781116129205760006128b9608083613afc565b90508087600001511161290e5760405162461bcd60e51b815260206004820152601960248201527f496e76616c696420524c502073686f727420737472696e672e00000000000000604482015260640161035f565b60019550935060009250612b71915050565b60bf8111612a0f57600061293560b783613afc565b90508087600001511161298a5760405162461bcd60e51b815260206004820152601f60248201527f496e76616c696420524c50206c6f6e6720737472696e67206c656e6774682e00604482015260640161035f565b600183015160208290036101000a90046129a48183613b42565b8851116129f35760405162461bcd60e51b815260206004820152601860248201527f496e76616c696420524c50206c6f6e6720737472696e672e0000000000000000604482015260640161035f565b6129fe826001613b42565b9650945060009350612b7192505050565b60f78111612a8a576000612a2460c083613afc565b905080876000015111612a795760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420524c502073686f7274206c6973742e000000000000000000604482015260640161035f565b600195509350849250612b71915050565b6000612a9760f783613afc565b905080876000015111612aec5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c696420524c50206c6f6e67206c697374206c656e6774682e000000604482015260640161035f565b600183015160208290036101000a9004612b068183613b42565b885111612b555760405162461bcd60e51b815260206004820152601660248201527f496e76616c696420524c50206c6f6e67206c6973742e00000000000000000000604482015260640161035f565b612b60826001613b42565b9650945060019350612b7192505050565b9193909250565b60606000806000612b8885612827565b919450925090506000816001811115612ba357612ba3613b13565b14612bf05760405162461bcd60e51b815260206004820152601860248201527f496e76616c696420524c502062797465732076616c75652e0000000000000000604482015260640161035f565b612bff85602001518484612eef565b95945050505050565b6060600082516002612c1a9190613c07565b67ffffffffffffffff811115612c3257612c326131ab565b6040519080825280601f01601f191660200182016040528015612c5c576020820181803683370190505b50905060005b8351811015612d84576004848281518110612c7f57612c7f613a9e565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016901c82612cb4836002613c07565b81518110612cc457612cc4613a9e565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506010848281518110612d0757612d07613a9e565b0160200151612d19919060f81c613bc2565b60f81b82612d28836002613c07565b612d33906001613b42565b81518110612d4357612d43613a9e565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080612d7c81613b5a565b915050612c62565b5092915050565b6000602082511015612d9f57506020015190565b8180602001905181019061059a9190613c44565b60006060602083600001511015612dd457612dcd83612fce565b9050612de0565b612ddd83612b78565b90505b61194b81612d8b565b606061059a612e0883602001516000815181106120fe576120fe613a9e565b612c08565b606082518210612e2c575060408051602081019091526000815261059a565b61194b8383848651612e3e9190613afc565b612fd9565b6000805b808451118015612e575750808351115b8015612ed85750828181518110612e7057612e70613a9e565b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916848281518110612eaf57612eaf613a9e565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016145b1561194b5780612ee781613b5a565b915050612e47565b606060008267ffffffffffffffff811115612f0c57612f0c6131ab565b6040519080825280601f01601f191660200182016040528015612f36576020820181803683370190505b509050805160001415612f4a57905061194b565b6000612f568587613b42565b90506020820160005b612f6a602087613c5d565b811015612fa15782518252612f80602084613b42565b9250612f8d602083613b42565b915080612f9981613b5a565b915050612f5f565b5060006001602087066020036101000a039050808251168119845116178252839450505050509392505050565b606061059a8261315a565b606081612fe781601f613b42565b10156130355760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015260640161035f565b826130408382613b42565b101561308e5760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015260640161035f565b6130988284613b42565b845110156130e85760405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015260640161035f565b6060821580156131075760405191506000825260208201604052613151565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015613140578051835260209283019201613128565b5050858452601f01601f1916604052505b50949350505050565b606061059a826020015160008460000151612eef565b60006020828403121561318257600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff811681146111c457600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156131fd576131fd6131ab565b60405290565b60405160a0810167ffffffffffffffff811182821017156131fd576131fd6131ab565b604051601f8201601f1916810167ffffffffffffffff8111828210171561324f5761324f6131ab565b604052919050565b600067ffffffffffffffff831115613271576132716131ab565b6132846020601f19601f86011601613226565b905082815283838301111561329857600080fd5b828260208301376000602084830101529392505050565b600082601f8301126132c057600080fd5b61194b83833560208501613257565b803563ffffffff811681146132e357600080fd5b919050565b6000806000606084860312156132fd57600080fd5b833561330881613189565b9250602084013567ffffffffffffffff81111561332457600080fd5b613330868287016132af565b92505061333f604085016132cf565b90509250925092565b60006020828403121561335a57600080fd5b813567ffffffffffffffff81111561337157600080fd5b8201601f8101841361338257600080fd5b61339184823560208401613257565b949350505050565b60008060008060008060c087890312156133b257600080fd5b86356133bd81613189565b955060208701356133cd81613189565b9450604087013567ffffffffffffffff8111156133e957600080fd5b6133f589828a016132af565b9450506060870135925061340b608088016132cf565b915061341960a088016132cf565b90509295509295509295565b60006020828403121561343757600080fd5b813561194b81613189565b600060a0828403121561345457600080fd5b60405160a0810167ffffffffffffffff8282108183111715613478576134786131ab565b816040528293508435835260208501356020840152604085013560408401526060850135606084015260808501359150808211156134b557600080fd5b506134c2858286016132af565b6080830152505092915050565b6000604082840312156134e157600080fd5b6134e96131da565b90508135815260208083013567ffffffffffffffff8082111561350b57600080fd5b818501915085601f83011261351f57600080fd5b813581811115613531576135316131ab565b8060051b9150613542848301613226565b818152918301840191848101908884111561355c57600080fd5b938501935b8385101561357a57843582529385019390850190613561565b808688015250505050505092915050565b600080600080600060a086880312156135a357600080fd5b85356135ae81613189565b945060208601356135be81613189565b9350604086013567ffffffffffffffff808211156135db57600080fd5b6135e789838a016132af565b945060608801359350608088013591508082111561360457600080fd5b9087019060a0828a03121561361857600080fd5b613620613203565b8235815260208301358281111561363657600080fd5b6136428b828601613442565b60208301525060408301358281111561365a57600080fd5b6136668b8286016134cf565b60408301525060608301358281111561367e57600080fd5b61368a8b8286016132af565b6060830152506080830135828111156136a257600080fd5b6136ae8b8286016132af565b6080830152508093505050509295509295909350565b805164ffffffffff811681146132e357600080fd5b6000602082840312156136eb57600080fd5b61194b826136c4565b60005b8381101561370f5781810151838201526020016136f7565b8381111561371e576000848401525b50505050565b6000815180845261373c8160208601602086016136f4565b601f01601f19169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff8516815260806020820152600061377f6080830186613724565b905064ffffffffff8416604083015263ffffffff8316606083015295945050505050565b60208152600061194b6020830184613724565b6000602082840312156137c857600080fd5b815161194b81613189565b6000606082840312156137e557600080fd5b6040516060810181811067ffffffffffffffff82111715613808576138086131ab565b6040528251815261381b602084016136c4565b602082015261382c604084016136c4565b60408201529392505050565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525063ffffffff8416604083015260806060830152611ddf6080830184613724565b6000825161388f8184602087016136f4565b9190910192915050565b600084516138ab8184602089016136f4565b60609490941b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001691909301908152601481019190915260340192915050565b600073ffffffffffffffffffffffffffffffffffffffff8087168352808616602084015250608060408301526139246080830185613724565b905082606083015295945050505050565b73ffffffffffffffffffffffffffffffffffffffff84168152826020820152606060408201526000612bff6060830184613724565b805182526020810151602083015260408101516040830152606081015160608301526000608082015160a0608085015261339160a0850182613724565b60208152600061194b602083018461396a565b6000602082840312156139cc57600080fd5b8151801515811461194b57600080fd5b838152600060206060818401526139f6606084018661396a565b83810360408501526040810185518252828601516040848401528181518084526060850191508583019450600093505b80841015613a465784518252938501936001939093019290850190613a26565b509998505050505050505050565b60008351613a668184602088016136f4565b60609390931b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169190920190815260140192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082821015613b0e57613b0e613acd565b500390565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60008219821115613b5557613b55613acd565b500190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613b8c57613b8c613acd565b5060010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600060ff831680613bd557613bd5613b93565b8060ff84160691505092915050565b600060ff821660ff841680821015613bfe57613bfe613acd565b90039392505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615613c3f57613c3f613acd565b500290565b600060208284031215613c5657600080fd5b5051919050565b600082613c6c57613c6c613b93565b50049056fea164736f6c6343000809000a",
  "devdoc": {
    "details": "The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2 epoch gas limit, it can be resubmitted via this contract's replay function. Runtime target: EVM",
    "kind": "dev",
    "methods": {
      "allowMessage(bytes32)": {
        "params": {
          "_xDomainCalldataHash": "Hash of the message to allow."
        }
      },
      "blockMessage(bytes32)": {
        "params": {
          "_xDomainCalldataHash": "Hash of the message to block."
        }
      },
      "initialize(address)": {
        "params": {
          "_libAddressManager": "Address of the Address Manager."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "relayMessage(address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))": {
        "params": {
          "_message": "Message to send to the target.",
          "_messageNonce": "Nonce for the provided message.",
          "_proof": "Inclusion proof for the given message.",
          "_sender": "Message sender address.",
          "_target": "Target contract address."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "replayMessage(address,address,bytes,uint256,uint32,uint32)": {
        "params": {
          "_message": "Message to send to the target.",
          "_newGasLimit": "New gas limit to be used for this message.",
          "_oldGasLimit": "Original gas limit used to send the message.",
          "_queueIndex": "CTC Queue index for the message to replay.",
          "_sender": "Original sender address.",
          "_target": "Target contract address."
        }
      },
      "resolve(string)": {
        "params": {
          "_name": "Name to resolve an address for."
        },
        "returns": {
          "_0": "Address associated with the given name."
        }
      },
      "sendMessage(address,bytes,uint32)": {
        "params": {
          "_gasLimit": "Gas limit for the provided message.",
          "_message": "Message to send to the target.",
          "_target": "Target contract address."
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "L1CrossDomainMessenger",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "allowMessage(bytes32)": {
        "notice": "Allow a message."
      },
      "blockMessage(bytes32)": {
        "notice": "Block a message."
      },
      "constructor": {
        "notice": "This contract is intended to be behind a delegate proxy. We pass the zero address to the address resolver just to satisfy the constructor. We still need to set this value in initialize()."
      },
      "pause()": {
        "notice": "Pause relaying."
      },
      "relayMessage(address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))": {
        "notice": "Relays a cross domain message to a contract."
      },
      "replayMessage(address,address,bytes,uint256,uint32,uint32)": {
        "notice": "Replays a cross domain message to the target messenger."
      },
      "resolve(string)": {
        "notice": "Resolves the address associated with a given name."
      },
      "sendMessage(address,bytes,uint32)": {
        "notice": "Sends a cross domain message to the target messenger."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12119,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "libAddressManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Lib_AddressManager)12111"
      },
      {
        "astId": 142,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "_initialized",
        "offset": 20,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 145,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "_initializing",
        "offset": 21,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 396,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 22,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 135,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 203,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "_paused",
        "offset": 0,
        "slot": "101",
        "type": "t_bool"
      },
      {
        "astId": 294,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 309,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "_status",
        "offset": 0,
        "slot": "151",
        "type": "t_uint256"
      },
      {
        "astId": 352,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "__gap",
        "offset": 0,
        "slot": "152",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 5253,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "blockedMessages",
        "offset": 0,
        "slot": "201",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 5257,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "relayedMessages",
        "offset": 0,
        "slot": "202",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 5261,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "successfulMessages",
        "offset": 0,
        "slot": "203",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 5265,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "failedMessages",
        "offset": 0,
        "slot": "204",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 5269,
        "contract": "contracts/L1/messaging/L1CrossDomainMessenger.sol:L1CrossDomainMessenger",
        "label": "xDomainMsgSender",
        "offset": 0,
        "slot": "205",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(Lib_AddressManager)12111": {
        "encoding": "inplace",
        "label": "contract Lib_AddressManager",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}